---
layout: single
title: "우아한 형제들 2차 인터뷰"
categories:
  - INTERVIEW
tags:
  - 우아한형제들
---

## 자기소개

안녕하세요. 이번에 우아한 형제들에 개발자로 입사지원한 남경호 입니다. 저는 지난 개발경력 동안 API 서버, Back-Office 서버, Batch 서버등 백앤드 서버개발에 대한 개발 경험을 가지고 있습니다.

처음 재직한 닉스테크라는 회사는 보안관련 솔루션을 판매하는 회사였습니다. 그곳에서 보안관제용 Back-Office 기능개발과 대시보드, 배치서비스, 보고서 및 Splunk, Archsight, Qradar와 같은 SIEM 장비 연동과 관련한 기능 개발을 담당하였습니다. 주로 데이터 연동과 저장된 데이터를 시각화 하는 부분을 집중적으로 개발하였습니다.

현재 재직중인 엑스트라이버라는 회사는 트립스토어라는 여행패키지 상품 가격 비교 플랫폼 서비스를 운영하고 있는 회사입니다. 주로 클라이언트를 위한 API 개발과 Back-office 및 배치 서비스 개발을 담당하였고, 현재는 B2B 사이트를 위한 API 개발을 담당하고 있습니다.
엑스트라이버에서는 API의 속도 및 다량의 데이터를 어떻게 다룰지, 어떻게 API를 설계하면 좋은지를 고민하며 개발을 진행하고 있습니다.

저는 우아한 형제들에서 제가 가진 이러한 역량을 잘 발휘하여 서비스를 발전시킬 수 있는 개발자가 될 수 있다고 자신합니다.

## 지원동기

우아한 형제들은 '개발잘하는 회사'와 '개발자가 일하기 좋은 회사'로 알려져있습니다. 미래를 쫓아가는 비전을 가진 회사가 아닌 미래를 선도하기 위한 비전을 가지고 회사 뿐만아니라 구성원 전체가 노력하는 회사라고 생각합니다. 저는 이런 비전과 개발문화를 가진 회사에 지원하지 않을 이유를 찾는것이 더 힘들것이라 생각합니다. 우연히 노션에서 개발팀 모집글을 읽게 되었습니다. 해당 팀에서 수행하게 되는 '프랜차이즈용 셀러 오피스'개발은 제가 지금까지 쌓아온 Back-office 개발 경험을 잘 발휘할 수 있을 것이란 생각을 가지게 되었고, 해당 팀에서 일하는 방식인 스크럼 방식은 현제 회사에서도 경험하고 있어 팀 구성원으로 쉽게 융화될 수 있을 것이란 기대를 가지고 지원하게 되었습니다.

## 이직사유

현재 제가 사용하고 있는 기술을 좀더 깊고 넓게 익히고 싶다는 욕구를 채우고 싶어서 이직을 결심하게 되었습니다. 우아한 형제들에서 작성하는 기술 블로그만 보아도 제가 고민하고 해결하고자 하는 이슈들에 대한 글들을 볼 수 있었습니다. 기술 블로그만 보아도 그럴텐데 만약 우아한 형제들의 구성원이 된다면 제가 고민하는 부분을 함께 고민하고 해결해 갈 수 있는 분들과 즐겁게 일하면서 함께 성장해 갈 수 있지 않을까 생각됩니다.

## 자신의 장점과 단점

저의 첫번째 장점은 성실함이라 생각합니다. 지난 회사와 현재 다니고 있는 회사에서 일찍 출근하는 직원 중 한명이었습니다. 물론 출근 시간으로 일을 잘하고 성실하다는 것을 말하려는 것은 아닙니다. 하지만 이 사례는 저의 성실함을 가장 짧고 잘 설명해드릴 수 있을 것이라 예를 들었습니다.

두번째는 커뮤니케이션 능력입니다. 첫번째 회사에서는 자사 솔루션을 개발하면서 사이트 담당자와 커뮤니케이션을 원활히 수행하였고, 현재 회사에서도 프로젝트를 진행하면서 운영담당자, 기획자, 디자니어, 동료 개발자들과 협업하면서 원활히 의사소통을 수행하며 프로젝트를 진행하였었습니다. 이렇듯 저는 많은 사람들과 의사소통을 하며 업무를 하는 것에 익숙하고 잘한다고 생각하여 두번째 장점이라 생각합니다.

단점으로는 하고싶은 욕심이 많은 것입니다. 그래서 하고싶은 것이 너무 많은데, 그렇다보니 TODO 리스트가 주체하지 못할 정도로 쌓이곤 하였습니다. 그래서 저는 제가 하고싶은 것들을 우선순위를 정하여 정리하고 하나하나 차근차근 이루어 가려고 노력하고 있습니다.

## 자신만의 강점 또는 핵심역량은 무엇이라 생각하나?

저는 저의 가장 큰 강점은 문제 해결능력이라고 생각합니다. 어플리케이션의 기능을 개발할 때 단순히 기술적인 요소들만 생각하는 것이 아닌 진짜 이해관계자가 원하는 것이 무엇인지 파악하려고 노력하고 개발합니다. 이러한 노력은 제가 어플리케이션에 대한 이해도가 높은 이유 중 하나이기도 한데요, 어플리케이션에 대한 이해도가 높으면 수정요구사항에 대해 기술적이거나 일정적인 부분에서 해결하기 어려운 부분에 대해서 단순히 "안된다"라는 부정적 답변을 하는 대신 가능한 다른 대안을 찾아줄 수 있습니다. 저는 이러한 역량을 바탕으로 지금까지도 동료들과 함께 프로젝트를 잘 진행해 왔고, 앞으로도 잘 진행해 갈 것이라 생각합니다.

## 최신기술 트랜드를 쫓아가는 방법

저는 최신 기술 트렌트를 쫓아가기 위해서 개발자나 개발팀의 기술블로그를 많이 읽어보고 있습니다. 블로그 글에서 관심이 가는 주제를 선정해서 관련 내용을 좀더 검색해 보거나 좀더 깊이 알고 싶으면 책을 구매해서 읽어보고 있습니다.

제가 보고 있는 사이트 중에 어썸데브블로그라는 사이트가 있는데 여기에 국내외 개발자 및 팀의 블로그들을 한눈에 볼 수 있어서 자주 이용하는 편입니다.

## 구성원들과 갈등이 생겼을 때 해결방법?

우선 구성원들과 갈등이 생기기 전에 발생할 징후를 포착하는 것이 가장 좋다고 생각합니다. 저는 이러한 징후가 포착되면 먼저 다가가 대화를 통해 문제를 해결하기 위해 노력합니다. 갈등이 생기기전에 그 징후는 반드시 나타난다고 생각합니다. 그래서 주의를 항상 기울인다면 갈등으로 인한 비용이 발생하는 문제를 사전에 차단할 수 있다고 생각합니다.

만약 사전에 갈등이 발생할 징후를 파악하지 못해서 갈등이 발생하였다면 저는 상대방의 생각을 먼저 경청하는 것으로 부터 시작하고자 합니다. 그 후 상대방의 감정이 나아졌을 때 저의 의견을 함께 제시하며 절충안을 마련하기 위해 노력합니다. 이 때 상대방의 의견을 수용하기 위한 저의 노력을 함께 보여준다면 상대방과 제가 둘다 만족할 수 있는 결과를 얻을 수 있었습니다.

## 미래의 자신의 모습을 설명하라

많은 동료들이 저와함께 일하고 싶어하는 개발자가 되고 싶습니다. 단지 유명하고 기술적으로만 뛰어난 개발자가 아니라 이사람과 함께 일하면 즐겁고 더 좋은것을 만들 수 있겠다라는 기대감을 줄 수 있는 그런 개발자가 되고 싶습니다. 기술이 부족하고 대인관계만 좋은 개발자라면 함께 일하고 싶지만 원하는 목표를 달성할 수 없을 것이고 기술만 좋은 개발자라면 함께 일하고 싶지 않을 것입니다. 저는 우아한 형제들에서 이러한 개발자가 되어서 많은 개발자가 우아한 형제들에서 좋은 개발을 하고 싶도록 만들겠습니다.

## 본인이 생각하는 좋은 회사란?

비전을 함께 공유하는 조직을 가진 회사가 좋은 회사라고 생각합니다. 조직에서 비전은 구성원들이 똘똘뭉쳐 같은 방향을 향해 나아갈 수 있는 원동력이라 생각합니다. 이런 비전을 제시할 수 있는 리더와 이 비전을 수행할 수 있는 구성원들이야말로 좋은회사가 아닐까 생각합니다.

## 협업 경험과 문제 대처법?

최근 수행했던 프로젝트의 진행방식은 스크럼 방식이었으며 페어프로그래밍과 코드리뷰를 하며 개발을 진행하였습니다. 2주의 기간을 주고 스프린트내에 스텍홀더와 기획자, 디자이너, 개발자들이 다함께 요구사항에 대한 유저스토리를 정의하였습니다. 그리고 해당 유저스토리를 기반으로 테스트 케이스를 작성하고 그 내용을 기반으로 개발자들은 테스크들을 생성하였습니다. 테스크 작성이 끝난 후 저희 팀원들은 페어프로그래밍과 코드리뷰를 진행하며 개발을 진행했습니다. 당시에는 회사 내 Q/A 부서가 존재하지 않아 개발이 완료 된 후 테스트 기간에는 프로젝트 참여자들이 다같이 모여 Q/A를 진행하였습니다.

해당 프로젝트를 진행할때 발생했던 문제는 다른 업무와의 우선순위 조정과 다른 프로젝트 업무를 함께 어떻게 병행할지에 대한 고민이었습니다. 개발 인원이 많지않아 한명이 다른 프로젝트를 함께 병행하는 경우가 많이 있었고 이러한 문제점을 해결하기 위해 데일리 스크럼을 통해 이슈를 항상 공유하며 일정을 조율하였습니다.

## 요즘 관심 분야?

Event Sourcing에 대해 공부하고 있습니다. 처음에 Event Sourcing의 개념을 접하고 공부하고자 하였을때 그 원리와 개념을 제대로 익히기에는 부족함이 많다고 생각했습니다. Event Sourcing에 대해 알아가고자 현재는 디자인 패턴을 공부하고 있습니다. 디자인 패턴을 공부하고 개발에 적용하기 위해서 TDD를 통한 개발을 실무에서 실행하고 있으며 Reactive Programing을 익히기 위해 Spring WebFlux를 이용한 개인프로젝트도 진행하고 있습니다. 앞으로 Event Driven 아키텍쳐에 대해서 공부할 예정이며 이러한 지식을 기반으로 Event Sourcing에 대해 알아가고자 하는 계획을 가지고 있습니다.

## 매일 하고 있는 공부가 있나? 그외 하고있는 일은?

디자인 패턴에 대해 좀더 잘알고 실무에 적용해보기 위해 공부하고 있으며, 매일 30분 이상은 개발서적을 읽으며 지식을 넓혀가기 위해 노력하고 있습니다.

개발활동 외에 짧은 경력이지만 개발자로서 경력이 쌓여가면서 한글로된 문서보다는 영어로된 문서를 볼일이 많아져서 영어 독해공부를 매일 아침 진행하고 있습니다. 영어 공부 방법은 평소 읽고 싶었던 영문 블로그나 레퍼런스 문서를 해석하는 방식으로 진행합니다.

공부 이외에는 최근 코로나 바이러스 때문에 헬스장에 가지 못하고 있지만 매일 하는 일은 운동입니다. 지난 2년동안 수영을 배웠고 최근에는 스피닝을 배우고 있습니다.

## 배달의민족 서비스의 장점과 단점

- 장점

  1. 배달의민족만의 색깔을 가지고 있습니다. 캐릭터, 디자인만 보더라도 배달의 민족만의 색깔을 가지고 있어 브랜드화가 아주 잘 되어 있습니다.

  2. 다양한 컨텐츠. 단순히 주문수단을 넘어서 무엇을 먹을지 고민할 수 있는 채널이 된다는것은 사용자들이 배달의민족 서비스를 좀더 충성도 있게 사용하게 될것이라는 점에서 장점이라 생각합니다.

- 단점
  제 관점에서는 배달의민족 서비스에서 단점을 찾기는 힘들었습니다. 다만 저와 같이 적은 용돈으로 생활하는 사람들에게는 좀 더 저렴한 가격을 가진 제품을 찾는 것이 매우 중요하다고 생각합니다. 동일한 브랜드라도 배달팁이라던지 최소배달금액이 다른 경우가 많은데요, 이러한 가게들을 손쉽게 비교할 수 있는 목록이 제공되면 좋지 않을까 라는 생각을 해봤습니다. 단순히 떠오르는 생각으로는 배달팁 또는 최소배달금액에 대한 정렬 기능이 있다면 어느정도 해결할 수 있지 않을까 생각됩니다.

## 좌우명은 무엇인가?

**Make it count** 현재의 이순간을 소중히 하자는 뜻입니다. 지나간 과거를 후회하지 않고 다가올 미래를 두려워하지 않으며 현재에 충실하자는 의미입니다.

## 나의 커리어에서 단기 장기 목표가 무엇인가?

저는 단기적으로 안정적이고 유연한 시스템을 잘 개발할 수 있는 개발자가 되는 것이 목표입니다. 저는 이를 위해서 디자인 패턴과 TDD에 대한 공부와 실습을 해오고 있습니다.

장기적으로는 안정적이고 유연한 시스템을 잘 설계할 수 있는 개발자가 되는 것이 목표입니다. 시스템을 잘 설계할 수 있는 개발자가 되기 위해서는 잘만들어진 서비스를 많이 개발하고 경험해야한다고 생각합니다. 그래서 저의 단기적인 목표를 달성하고 유지하면서 장기적인 목표를 달성하기 위해 노력해 나갈 것입니다.

## 갑자기 많은 업무량이 주어진다면?

만약 예상치 않게 저에게 많은 업무가 주어진다면 우선 일에 대한 우선순위를 먼저 따진 후에 일정을 먼저 정리하는 작업부터 진행하겠습니다. 일정을 산출하였을 때 물리적으로 제시간에 처리할 수 없다고 판단되면 미리 팀의 동료나 팀장님께 이슈를 공유하고 해결방안을 모색하도록 하겠습니다.

## 자신을 한단어로 표현한다면

"유연함" 저를 한단어로 표현한다면 유연함이라고 말하고 싶습니다. 저는 업무를 진행함에 있어서 유연함을 중요하게 생각하고 항상 유연함을 읽지 않기 위해 노력하고 있습니다. 개발자에게 코드의 유연함과 사고의 유연함은 꼭 필요한 덕목이라고 생각합니다. 그래서 저는 이러한 유연함이 저를 표현하고 표현되고 싶은 단어입니다.

## 다른 직무로 배치된다면?

우아한 형제들의 직무에 대해서는 저보다 구성원을 배치하시는 관리자분들께서 훨씬 더 잘알고 계신다고 생각합니다. 이 분들께서 제가 가진 역량에 맞는 적합한 직무에 배치해 주신다면 기꺼이 따르겠습니다. 저는 배치된 직무에 잘 적응하여 제 역량을 발휘하고자 할것이며 만약 그 직무가 제 적성과 맞지 않거나 좀더 원하는 직무가 있다면 저의 능력을 좀더 키워서 그때 관리자 분들께 저의 이러한 바램을 어필해 보겠습니다.

## 지난 프로젝트의 성과

현재 트립스토어 앱에서 노출되고 있는 특가를 설정하는 기능을 개발하는 프로젝트에 대한 성과를 말씀드리고 싶습니다. 특가 기능을 개발하기 전에는 영업실 담당자와 상품을 소싱하는 개발 담당자가 직접 수동으로 특가를 적용할 상품을 선별하고 적용하는 업무를 계속해 왔었습니다. 해당 담당자들은 성수기에 이 업무로 인해 휴가를 가지도 못하기도 하였습니다.

특가 프로젝트는 다가오는 성수기를 대응하기 위해 시작된 프로젝트로 트립스토어에서 제공하는 모든 상품중에 특가를 적용할 상품을 선별하고 지정된 특가를 적용하는 기능을 개발하는 것이었습니다.

이 기능을 개발함으로써 현재까지 트립스토어는 특가를 이용한 프로모션을 진행할 수 있게 되었으며, 이전까지 특가를 담당하던 분들은 특가 업무가 아니 다른 업무를 담당 할 수 있었으며, 특가 프로젝트 이후 휴가도 자유롭게 갈 수 있게 되었습니다.

## 다량의 데이터를 다루면서 경험한 내용

트립스토어는 500만건의 행사들이 매일 추가되거나 변경됩니다. 특가 프로젝트를 진행하면서 많이 고민했던 부분이 동시성으로 인한 비관적 잠금문제 해결과 적용 시 속도문제를 개선하는 것이었습니다.

특가 적용을 위한 방법으로 스케줄링을 이용하여 특가를 적용/해제하는 방법을 사용하였는데요, 특가가 적용되는 시점에 특정 상품을 누군가 조회하고 있었다면 **비관적 잠금 예외**가 발생합니다. 이러한 예외를 줄이기 위해 Transaction의 범위를 줄여 보았지만 간헐적으로 문제는 지속적으로 발생하여 근본적으로 스케줄링을 통한 특가를 적용/해제 되는 것이 아닌 특가 정책이 입력될 때 각 행사마다 특가를 미리 적용해 두고, 조회 시점에 조건에 맞는 특가를 조회하는 방식으로 변경하고 있습니다.

이 방식을 도입함으로 써 비관적 잠금 문제를 해결과 특가가 적용되는 시점의 차이가 발생하는 문제를 해결할 수 있습니다.

## 자신은 프론트엔드에 어울리나 백엔드에 어울리나?

저는 화면을 어떻게 디자인할지에 대한 고민보다 시스템을 어떻게 설계할지에 대한 고민하는 것이 더 즐거워서 백엔드 개발자에 더 어울린다고 생각합니다. 하지만 Back Office 어플리케션 개발에 대한 경험도 있어서 그런지 프론트엔드 기술에도 많은 관심을 가지고 있습니다.

## 서버 장애에 대처해본 경험?

2019년 초에 서비스가 점점 발전하면서 프로모션을 위한 마케팅 푸시를 보내 특정 시간 내 다수의 유저가 유입되면 서버가 다운되는 현상을 겪었었습니다.

장애원인은 Elastic cache와 database connection pool 문제였습니다.

가장 먼저 발견된 문제는 Elastic cache의 문제였었는데요, 서버가 다운되었을 때 우선 서비스 정상화를 위해서 캐시 서버를 재시작한 후 캐시서버의 로그를 살펴 보았습니다.

원인은 master cache에 다량의 데이터가 write 되면서 발생한 문제였습니다. 이는 이전에 개발된 API 서버에서 불필요한 cache write 코드를 제거함으로써 해결하였습니다.

두번째로 발견된 문제는 database connection pool의 문제였습니다.
첫번째 문제로 인해 이 두번째 문제는 가려졌었는데요. 첫번째 문제를 해결하고 난 후에 이 두번째 문제가 발생한다는것을 알수 있었습니다.

발생한 원인은 Spring boot에서 제공하는 pool의 개수를 기본설정값으로 지정하였는데 이 개수를 적정한 수로 늘려줌으로써 해결하였습니다. 적정 크기는 `(CPU 코어 수 * 2) + RAID 개수` 로 하였습니다.

## 자바는 어느정도 다루나?

전문가라고 할 순 없지만, 요구사항에 맞는 기능을 제가 원하는 방식으로 다른사람의 도움없이 구현할 수 있습니다.

## 트래픽 과부하가 생기면 어떻게 할것인가?

트래픽의 과부하가 발생하기 전에 미리 예측할 수 있다면 가장 좋을 것이라 생각합니다. 예를 들면 대규모 마케팅 프로모션이 있을 예정이라면 예상되는 병목지점이라던가 어플리케이션에서 예상되는 문제가 없는지 부하테스트 등을 통해 미리 준비해둘 것입니다.

미리 대응하지 못해 운영 중 과부하가 발생한다면 과부하가 발생하는 지점에 스케일 아웃을 우선적으로 고려해 볼것입니다. 그런 후에 병목지점을 찾아내어 근본적인 문제점을 해결하기 위한 방법을 모색해 나가겠습니다.

## 생각나는 개발서에서 인상깊었던 부분을 말해보라

저는 클린코드를 읽고난 후 가장 기억에 남는 메시지는 '작게'였습니다.
클린코드에서는 '함수를 작게 만들어라'와 '책임을 작게 가지도록 해라'와 같은 구체적인 가이드라인을 제시하는 것 뿐만 아니라 코드의 중복을 줄이고 의미있는 변수명을 사용하는 등 동료가 코드를 이해하고 읽는 시간을 줄이는 것 등의 '작음'을 추구하는 방법에 대한 가이드라인도 제시해 주었습니다.

저는 개발자에게 이러한 '작음'을 추구하는것이 얼마나 중요한지를 느껴가고 있습니다. 그래서 저는 클린코드에서 이 '작음'이라는 메시지가 가장 인상 깊었습니다.

## 사용해본 디자인 패턴에 대해 설명해 보라

- Dependency Injection

  구성요소간에 의존관계가 소스코드의 내부가 아니라 외부의 설정파일등을 통해 정의되도록 하는 디자인 패턴입니다. 의존 주입 시 구현체가 아닌 인터페이스를 주입함으로써 종속성을 감소 시키고 재사용성을 높일 수 있습니다. 거기다 테스트 코드를 작성하기에도 용이합니다.

  제어의 역전의 장점을 활용할 수 있습니다.
  제어의 역전은 프로그램의 수행과 구체적인 구현을 분리할 수 있으며, 구현체간의 변경이 용이합니다. 그리고 프로그램간의 의존성이 낮아지는 장점이 있습니다.

  ```java
  class Controller {
      private Service service;

      public Controller(Service service) {
        this.service = service;
      }

      public void run() {
        service.do();
      }
  }

  interface service {
      public void do();
  }

  class serviceImpleA {
      public void do() {
        // ...
      }
  }

  class serviceImpleB {
      public void do() {
        // ...
      }
  }
  ```

- Decorator

주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴입니다.
상속에 비해 유연한 디자인을 만들 수 있으며, OCP 원칙을 지킬 수 있다.

```java

interface AuthProvider {
    public boolean isAuth(String id, String pw);
}

class OfficeAuthProvider implements AuthProvider {
    public boolean isAuth(String id, String pw) {
      boolean isAuth = false;
      // ... authorize logic
      return isAuth;
    }
}

class OfficeAuthProviderDecorator implements AuthProvider {

    private AuthProvider authProvider;

    public boolean isAuth(String id, String pw) {
      boolean isAuth = false;

      if (isDevelopIdentification(id, pw)) {
          isAuth = ture;
      } else {
          isAuth = authProvider.isAuth(id, pw)
      }

      return isAuth;
    }
}

```

## String, StringBuilder, StringBuffer 차이점

- String
  불변개체로 새롭게 문자열이 생길때마다 메모리 공간이 새롭게 생성된다. 그래서 연산시 성능이 좋지 않지만 불변하기 때문에 Thread-Safe하다. 연산이 적고 멀티 쓰레드 환경에서 사용하기에 적합하다.

- StringBuilder
  문자열 연산 시 높은 처리속도를 보여준다. 하지만 동기화를 제공하지 않기 때문에 Thread-Safe하지 못하다. 그래서 멀티쓰레드 환경에서 사용하기에는 적합하지 못하다.

- StringBuffer
  문자열 연산 시 동기화를 지원하기 때문에 Thread-Safe하다. 그래서 멀티 쓰레드 환경에서 사용하기에 적합하다. 다만 연산속도는 StringBuilder에 비해 떨어진다.

## 코틀린을 사용하면서 느꼈던 장점과 단점

- 장점

  - 코드가 간결해진다. 그래서 가동성이 좋아진다.
  - null safe하기 때문에 null pointer exception이 발생할 가능성을 많이 줄일 수 있다.
  - 자바와의 높은 호환성으로 자바 사용자들도 익숙하게 사용할 수 있다.
  - extention function 지원
  - data 클래스 지원
  - immutability

- 단점 (단점이라고 하기보다 제가 느꼇던 어려움)
  - 빌드 시간이 자바보다 오래 걸리는 단점이 있다.
  - 자바와 높은 호환성은 제공하지만 자바와는 다른 패러다임을 가지고있어 코틀린스럽게 코드를 작성하는 것을 익히는데는 시간이 다소 소요될 수 있다.

## TDD에 대해 설명하라

테스트 주도 개발은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나로 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다. 그후 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다. 마지막으로 작성한 코드를 표준에 맞도록 리펙토링한다. 이러한 일련의 과정을 TDD라고 합니다.

## 스크럼과 칸반의 차이점?

- 스크럼
  스프린트를 기반으로 애자일 방법론을 실행하는 것을 말합니다. 스프린트 작업단위를 부여하고 작업을 계획, 실행 후 회고하는 방식입니다. 짧은 개발 주기와 피드백을 추구합니다.
  주목할만한 특징 중 하나는 Hot Fix는 현재 진행중인 스프린트에 절대 넣지 않는 것입니다.

- 칸반
  현재 실행중인 작업을 제한하여 애자일 방법론을 실행합니다. 칸반의 주요 특징은 스크럼과 달리 스프린트 기간이 정해지지 않는다는 것입니다. 이슈가 생기면 백로그에 쌓이게 되고 작업자는 작업할 여유가 되면 해당 카드를 자신에게 할당하여 진행중 상태로 변경하여 철하는 방식입니다. 언제 그 일이 처리가 될지는 정해지지 않습니다. 스크럼과 다르게 Hot Fix는 언제든지 백로그에 추가될 수 있고 우선순위에 따라 언제든지 먼저 처리될 수 있습니다.

## 리펙토링이란?

'결과의 변경없이 코드의 구조를 재조정함'을 의미합니다. 주로 가독성을 높이고 유지보수를 편하게 하기 위해 사용됩니다. 버그를 없애거나 새로운 기능을 추가하는 것은 리펙토링이라고 할 수 없습니다. 그래서 사용자가 보는 외부 인터페이스는 그대로 두면서 내부 논리나 구조를 바꾸고 개선하는 유지보수 행위를 말합니다.

저는 리펙토링에서 자동화된 테스트코드가 없는 리펙토링은 반쪽짜리 리펙토링이라고 생각합니다. 왜냐하면 결과의 변경이 없었다는 것을 보장해주는 것이 자동화된 테스트 코드이기 때문입니다.

## 속력과 속도의 차이

- 속력
  속력은 여러분이 여행하는데 들어간 시간과 여행한 거리의 관계, 즉 시간당 거리를 말합니다. 다른말로 한다면 1초에 몇 m를 이동하였는가를 나타내는 단위라고 할 수 있습니다. 여기에는 방향은 포함되어있지 않습니다.

- 속도
  속도는 거리, 시간, 방향을 모두 나타냅니다. 속도를 다르게 설명한다면 1초동안 처음위치에서 얼마의 변화가 있느냐를 나타내는 값을 속도라고 합니다. 예를 들어 자동차가 일정한 속력으로 직선을 달릴때는 속도와 속력은 동일합니다. 하지만 자동차가 구불구불한 도로를 달릴때에는 속력은 일정해도 속도는 일정하지 않습니다.

## 기술블로그에서 가장 인상 깊었던 글?

저는 **도움이 될수도 있는 JVM memory leak 이야기**라는 글이 인상 깊었습니다.
메모리 누수에 대해 원인을 파악하기 위해 접근하는 방식이 아주 흥미로웠습니다. 원인을 파악하기 위해 하나의 가설을 세우고 그것을 확인한 후 다른 가설을 세워 결과를 도출해내는 방식은 제가 글을 읽으면서 개발할 때 어떠한 태도를 가지면 좋을지에 대한 생각을 하게끔 해주었습니다.

## DB의 격리수준에 대해 설명하라

1. Read-Uncommitted
   트랜잭션의 변경내용이 Commit이나 Rolback의 여부에 관계없이 다른 트랜잭션에서 보여집니다. 동시처리 성능이 가장 높습니다.
   dirty-read, non-repeatable-read, phantom-read 문제가 발생할 수 있습니다.

2. Read-Committed
   어떤 트랜잭션에서 데이터의 변경이 일어나도 Commit이 완료된 데이터만 조회가 가능합니다.
   non-repeatable-read, phantom-read

3. Repeatable-Read
   트랜잭션 내 조회한 데이터의 내용이 항상 동일함을 보장해줍니다.
   phantom-read

4. Serializable
   트랜잭션 내 조회한 데이터의 내용이 항상 동일하며 다른 트랜잭션에서 변경 또한 불가능합니다.
   dead-lock

- dirty-read : A 트랜잭션에서 레코드의 데이터를 1에서 2로 변경하고 아직 커밋하지 않았을때 B 트랜잭션에서 동일 레코드를 조회하면 조회한 데이터는 2가 될 것입니다. 이때 A 트랜잭션이 롤백이 실행되고 B 트랜잭션에서 조회한 데이터 2를 3으로 변경한다면 정상적이지 않은 변경일 수 있을 것입니다.

- non-repeatable-read : A 트랜잭션에서 데이터를 조회할 때 데이터가 1이었고, B 트랜잭션에서 해당 레코드의 데이터를 1에서 2로 변경이 발생하였다면 A 트랜잭션에서 데이터를 다시 조회하였을 때 조회된 데이터는 2가 됩니다. 그런데 B 트랜잰션에서 롤백이 발생하고 A 트랜잭션에서 데이터를 2에서 3으로 변경한다면 정상적으로 변경된 것이 아닐 수 있습니다.

- phantom-read : A 트랜잭션에서 1의 조건으로 데이터를 검색하였고, B 트랜잭션에서 1조건의 가진 데이터를 새롭게 추가/삭제/변경하는 경우, A 트랜잭션에서 1의 조건으로 데이터를 다시 검색하였을 때 B 트랜잭션에서 변경한 데이터를 조회할 수 있게 됩니다. 이때 B 트랜잭션에서 롤백을 실행한 후 A 트랜잭션에서 조회한 데이터를 변경하게 되면 해당 데이터들은 정상적인 변경이 아닐 수 있습니다.

아래로 내려갈수록 격리수준이 높아져 위에 언급한 문제가 발생할 가능성은 줄어들지만 동시 처리 성능은 떨어집니다.

- shared-lock : select에 대한 lock을 직접 걸지 않고 innoDB가 각 행에 대한 lock을 실행한다.
- exclusive-lock : update, delete에 대한 lock을 실행한다.

## 자바 버전별 기능 차이

- 자바 7

  - <> 지시자
  - switch문에서 String 클래스 지원
  - 자동자원관리
    ```
    try () {
      //...
    } catch(Exception e) {
      //...
    }
    ```
  - Multi-Catch 기능
    ```
    try {
      //...
    } catch(Exception e) {
      //...
    } catch(Exception e) {
      //...
    } catch(Exception e) {
      //...
    }
    ```

- 자바 8

  - 람다 표현식 추가
  - Stream API 추가
  - java.time 패키지 추가

- 자바 9

  - 불변 collection 생성함수 추가
  - interface 내에서 private 함수 사용 가능
  - Reactive Stream API 추가
  - Http2 클라이언트 제공

- 자바 10

  - 로컬변수 `var`를 이용한 선언

- 자바 11

  - `java.net.http` 새로운 표준 HTTP 라이브러리
  - 람다에서의 `var` 변수 사용

- 자바 12

  - 스위치문 확장 (옵션을 줘야함)

- 자바 13
  - 스위치문 확장 (옵션을 줘야함)
  - Text Block (옵션을 줘야함)

## 스프링 버전별 차이

- Spring 3

  - Java 5+ 지원
  - REST API 지원

- Spring 4

  - Java 8
  - Starter Pack 지원
  - 람다식, Optional 등을 프레임워크레벨에서 지원
  - REST 방식 컨트롤러 지원

- Spring 5

  - Java 8 표준, 8+ 버전 지원
  - Reactive 프로그래밍 모델 지원
  - 함수형 프로그래밍 with Kotlin
  - Test 향상

## 우아한 형제들 회사정보

근면성실
근면(부지런히 일하며 힘씀)하고, 성실(정성스럽고 참됨)한 자세로 자신에게 주어진 일에 최선을 다해 개인 및 회사의 가치를 실현하고자 노력하는 인재.
우아한형제들의 구성원들은 근면성실함이 모든 일의 기본임을 잊지 않고 항상 부지런하고 정성스럽게 임합니다. 누가 보지 않아도 묵묵히 제 할 일을 다하는 거북이가 어쩌면 조금 늦을지라도 결국은 잔꾀 많은 토끼를 이긴다는 진리를 믿습니다.

새시대 새일꾼
새로운 기술을 익히고 새 시대의 흐름을 파악하여 고객의 기호가 어떤 방향으로 변하는지 끊임 없이 연구하는 인재.
우아한형제들의 구성원들은 끊임 없이 변화하는 환경을 고려하며 일합니다. 그 중심에는 고객이 있습니다. 고객 창출과 고객 만족을 위해 시대의 흐름을 주도하고 이를 위해 필요한 새로운 기술과 역량을 확보하는데 주저하지 않습니다.

근검절약
근검(부지런하고 검소하며 노력을 들여 일함), 절약(함부로 쓰지 않고 꼭 필요한 데에만 써서 아낌)하는 마음가짐과 태도를 습관으로 가진 인재.
우아한형제들의 구성원들은 성실하게 일해 얻은 이익을 낭비하지 않고, 오늘의 씀씀이를 아껴 내일에 대비하는 생활의 지혜를 몸소 실천합니다.
또, 아끼고 남긴 것을 사회적으로 더 좋은 일을 위해 쓸 수 있는 넉넉한 마음을 갖습니다.

배려와 협동
배려(도와주거나 보살펴 주려고 마음을 씀)하고 협동(서로 마음과 힘을 하나로 합함)을 통해 성과를 만들어 내는 인재. 우리는 작은 말과 행동이 주변에 미칠 영향에 대해 사려 깊게 생각하고 행동합니다. 자기 자신에 대한 믿음과 사랑에서 출발해 동료에 대한 배려로 확장해 가는 것의 즐거움을 알며, 항상 유쾌하고 박력 있게 생활함으로써 주변에 긍정적인 분위기를 전파합니다.

규율위의 자율
우리는 규율 위에 세운 자율적인 문화를 지향합니다.

스타보다 팀웍
회사란 평범한 사람들이 모여 비범한 성과를 내는 곳! 천재 한 사람에 의지한 조직이 아닌, 팀웍을 통해 성과를 내는 조직을 지향합니다.

진지함과 위트
일에 대한 진지함을 잃지 않으면서도, 쉽고 명확하고 위트있게 문제를 풀어나갑니다.

열심만큼 성과
열심히 하는 것은 중요합니다. 하지만, 성과를내는 것은 더욱 중요합니다.
과정과 결과는 둘 중 어느 하나만 선택하거나, 우선시할 수 없는 문제입니다.

## 질문?

- 개발자들이 사용하는 장비와 도서 지원 등 사내 지원 범위가 어떤지 궁금합니다.

- 우아한 형제들에서는 일 잘하는 사람이란 어떤 사람인지 궁금합니다.
