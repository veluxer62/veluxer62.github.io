---
layout: single
title: "우아한 형제들 인터뷰 준비"
categories:
  - INTERVIEW
tags:
  - 우아한형제들
---

## 예상질문

### 구성원들과 갈등이 생겼을 때 어떤 방식으로 해결할 수 있나?

우선 구성원들과 갈등이 드러나기 전에 갈등이 발생할 징후가 발생할 때에 먼저 다가가서 얘기하고자 노력합니다. 저는 갈등이 생기기전에 반드시 그 징후를 느낄 수 있다고 생각합니다. 그 갈등이 생기기전에 적극적으로 다가가 그 갈등이 발생하는 원인에 대해 알아가고 해결하기 위해 노력한다면 실제 갈등이 발생할 확율을 줄여주거나 발생하더라도 그 갈등을 해결하는데 드는 노력을 많이 줄일 수 있다고 생각합니다.

만약 사전에 갈등 발생 징후를 느끼지 못한 상황에서 갈등이 발생하였다면 저는 상대방의 의견을 수용하는 것에서 해결을 위한 노력을 시작합니다. 그 후 상대방의 감정이 갈등 당시보다 나아졌을 때 저의 의견을 다시 한번 말합니다. 그때에는 최대한 조정을 위한 나의 노력을 보여주고자 하며 그렇게 하였을 때 상대방과 제가 원하는 바를 서로 얻을 수 있는 결과를 볼 수 있었습니다.

### 자신의 장점과 단점이 무엇인가?

저의 첫번째 장점은 성실함이라 생각합니다. 지난 회사와 현재 다니고 있는 회사에서 일찍 출근하는 직원 중 한명이었습니다. 물론 출근 시간으로 일을 잘하고 성실하다는 것을 말하려는 것은 아닙니다. 하지만 이 사례는 저의 성실함을 가장 짧고 쉽게 설명드릴 수 있을 것이라 생각되어 예를 들었습니다.

두번째는 적응력 입니다. 현재 재직중인 회사에서는 이전에 다니던 회사와 다른 기술과 업무방식을 사용하고 있습니다. 저는 제가가진 이 적응력으로 한달 정도 내에 기술과 업무방식을 습득하고 바로 혼자서 맡은바 일을 해내는 구성원이 되었습니다. 이점은 제가 우아한 형제들에 새롭게 입사하더라도 빠르고 쉽게 그 부서에 적응할 수 있을 것입니다.

단점으로는 하고싶은 욕심이 많은 것입니다. 그래서 하고싶은 것이 너무 많은데, 저는 제가 하고싶은 것들을 정리하고 하나씩 차근차근 이루어가려고 노력하고 있습니다. 예를 들면 블로그를 쓰고싶은 것들이 너무 많은데 이렇게 쓰고싶은것들을 ISSUE로 정리하여 하나씩 Close 해 가능 방식을 사용합니다.

### 우리 회사에 지원한 이유는 무엇이며, 우리 회사에 대해 얼마나 알고 있나?

'개발잘하는 회사'와 '개발자가 일하기 좋은 회사'로 알려져있습니다. 미래를 쫓아가는 비전을 가진 회사가 아닌 미래를 선도하기 위한 비전을 가지고 회사뿐만 아니라 구성원 전체가 노력하는 회사라고 생각합니다. 저는 이러한 비전을 가진 회사에 지원하지 않을 이유를 찾는 것이 더 힘들것이라 생각합니다.
우연히 노션에서 개발팀 모집글을 읽게 되었습니다. 해당 팀에서 수행하게 되는 '프랜차이즈용 셀러 오피스'개발은 지금까지 제가 쌓아온 backoffic 개발 경험을 잘 발휘할 수 있을 것이란 생각을 가지게 되었고, 해당 팀에서 일하는 방식인 스프린트 방식은 현재 회사에서도 경험하고 있어 팀원들에게 쉽게 융화될 수 있을 것이란 기대감을 가지고 지원하게 되었습니다.

### 스프린트란 무엇인가?

에자일 방법론 중 하나로 짧게는 1주에서 길게는 4주정도 짧은 주기의 기간동안 개발하고 피드백을 받는 방식의 개발을 반복하면서 소프트웨어를 개발하는 방법을 말합니다. 스프린트에서 중요한것은 짧은 주기의 개발과 피드백입니다. 1~4주 내에 개발할 수 있을 만큼만 개발하고 회고와 같은 피드백을 통해 다음 스프린트를 계획하고 소프트웨어의 개발의 방향을 잡아가는 것입니다. 긴 주기의 개발 후 마음에 들지 않는 경우 이미 상당히 개발되어 있는 소프트웨어는 변경 비용이 클 수 밖에 없습니다. 스프린트는 개발 주기를 짧게 가지면서 개발 후 변경에 대한 의견을 적극적으로 수용할 수 있다라는 장점을 가질 수 있습니다. 그리고 잦은 피드백은 개발자가 이해관계자의 요구사항을 제대로 개발하고 있는 지에 대한 방향성을 잘 잡아 준다는 점에서 중요한 장점이라고 생각합니다.

### 우리 회사에 대해 어떻게 생각하나?

프로그래머 양성 전문 학교인 '우아한테크코스'를 운영하고 있는 것으로 알고 있습니다. 좋은 개발자를 채용하기만 할 목적이 아닌 좋은 개발 문화를 만들기 위한 노력은 회사의 눈앞의 이득을 위해 호수를 바라보는 것이 아닌 큰 바다를 바라보고 있다고 생각합니다.
'좋은'회사가 되기 위한 우아한형제들의 노력은 다른 기업들에게 좋은 영감을 주고 있다는 점에서 우아한 형제들은 선구자라고 생각합니다.

## 오픈소스의 장점은 무엇이라 생각하나?

1. 비용절감
   오픈소스는 일단 무료로 사용가능합니다. 가장 중요한 장점이 아닐까 생각합니다. 비용에 대한 부담이 적기에 많은 사람들이 사용하게 될 것이고 많이 사용된다는 것은 더욱더 발전할 수 있는 원동력이 된다고 생각합니다.

2. 빠르고 유연한 개발
   특정 조직에서 독점하고 있는 소프트웨어는 최신 트랜드에 둔감할 수 밖에 없고 발생한 문제점을 발견하고 해결하는데 늦어질 수 밖에 없습니다. 오픈 소스는 많은 사람들이 기여하므로 최신 트랜드를 적극 반영하고 발생한 문제점을 다같이 고민하고 해결하기 때문에 빠르고 유연하게 개발할 수 있습니다.

3. 호환성/유연성
   다양한 사람들의 참가는 오픈소스가 다양한 방식으로 기능을 제공할 수 있는 기회를 가진다고 생각합니다. 특정 상황에만 맞는 기능을 가지는 것이 아닌 다양항 상황에 맞출 수 있도록 개발된 소프트웨어는 호환성과 유연성을 가질 수 있습니다.

4. 신뢰성/안정성
   세계의 수많은 전문가들이 오픈소스에 참가하므로 폐쇄적으로 개발되는 소프트웨어에 비해 신뢰성과 안정성이 높다.

### 미래 자신의 모습을 설명해 보라.

많은 사람들이 나와함께 일하고 싶어하는 개발자가 되고 싶습니다. 단지 유명하고 기술적으로만 뛰어난 개발자가 아니라 이사람과 함께 일을 하면 즐겁고 더 좋은 것을 만들어 낼 수 있겠다라는 기대감을 줄 수 있는 그런 개발자가 되고 싶습니다. 기술이 부족하면 같이 일하고 싶어도 원하는 목표를 달성 할 수 없을 것이고 대인관계력이 부족하다면 그사람과 같이 일을 하고 싶지 않을 것입니다. 저는 지금도 기술을 발전시키기 위한 노력을 계속하고 있으며 동료들과의 좋은 관계를 유지하기 위해 회고를 하며 지난 행동들을 반성하며 개선하기 위한 노력을 하고 있습니다.

### 이직 사유는 무엇인가?

현재 제가 사용하고 있는 기술을 좀더 깊고 넓게 익히고 싶다는 욕구를 채우고 싶어서 이직을 결심하게 되었습니다. 우아한 형제들에서 작성하는 기술 블로그만 보아도 제가 고민하고 해결하고 싶어하는 글들과 배울점들을 많이 볼 수 있습니다. 기술 블로그만 보아도 그럴텐데 만약 우아한 형제들의 구성원이 된다면 제가 고민하는 부분을 함께 고민하고 해결해 갈 수 있는 분들과 즐겁게 일하면서 성장할 수 있지 않을 까 생각됩니다.

### 본인이 생각하는 좋은 회사란 무엇인가?

비전을 함께 공유하는 조직을 가진 회사가 좋은 회사라고 생각합니다. 조직에서 비전은 구성원들이 똘똘뭉쳐 같은 방향을 향해 나아갈 수 있는 원동력이라고 생각합니다. 이런 비전을 제시할 수 있는 리더와 이 비전을 잘 수행할 수 있는 구성원들이야말로 좋은 회사가 아닐까 생각됩니다.

### 협동하며 일을 진행했던 경험은? 혹은 협업 시 문제가 생기면 어떻게 대처 했나?

최근 프로젝트의 진행방식은 스프린트방식으로 페어프로그래밍과 코드리뷰를 하며 개발을 진행하고 있습니다. 하나의 사이클을 설명드리자면 먼저 하나의 스프린트 내 진행할 개발 스펙을 정리하고 스텍홀더와 기획자, 디자이너, 개발자들이 다함께 요구사항에 대한 유저스토리를 정의합니다. 해당 유저스토리를 기반으로 Test case를 작성하게 되고 해당 내용을 바탕으로 개발자들은 Task들을 생성합니다. Task 작성이 끝나면 개발자들은 팀원과 함께 설계하고 페어프로그래밍과 코드리뷰를 진행하며 개발을 진행합니다. 현재 회사 내 테스트를 위한 전문 부서가 존재하지 않아 개발이 완료 된 후 테스트 기간에는 다같이 테스트를 진행합니다.

협업 시 가장 많이 발생하였던 문제는 바로 다른 업무와의 우선순위 조정과 함께 병행하는 업무를 어떻게 처리하는 것인지에 대한 고민이었습니다. 개발 인원이 많지 않아 한명이 다른 프로젝트를 병행하는 경우가 왕왕 있었고 이러한 문제점은 데일리 스크럼을 통해 이슈를 항상 공유하며 해결하였습니다.

### 자신은 프론트엔드에 어울리는가 백엔드에 어울리는가?

저는 화면을 어떻게 디자인할지에 대한 고민보다 시스템을 어떻게 설계할지에 대한 고민하는 것이 더 즐거운것 같아 백엔드 개발자에 더 어울린다고 생각합니다. 하지만 Back office 어플리케이션을 많이 만들다 보니 프론트엔드 기술에도 많은 관심을 가지고 있습니다.

### 밤을 새서 코딩한 기억이 있나?

밤을 완전히 샌적은 없고 새벽까지 코딩을 한 경험은 있습니다. 하지만 저에게는 밤늦게까지 코딩하는 스타일은 잘 맞지 않는 것 같습니다. 오히려 저는 아침에 코딩하는 것이 머리가 맑고 더 잘 되는 것 같습니다. 그래서 차라리 새벽에 일어나서 코딩하는 것이 밤늦게까지 코딩하는 것 보다는 좋다고 생각합니다.

### 업무를 수행하며 주로 활용하는 툴은 무엇인가?

인텔리J, git, slack, VSCode, putty, dbeaver, postman 등을 사용합니다.

### 지난 프로젝트의 성과를 설명해 보라. 기억에 남는 업무가 있다면?

현재 트립스토에 사용되고 있는 특가를 설정하는 기능을 개발하는 프로젝트가 기억에 남습니다. 특가 프로젝트 전에는 영업실 담당자와 데이터를 소싱하는 개발자가 수기로 관리하고 적용하며 비생산적으로 특가를 적용하는 업무를 계족해 오고 있었습니다. 담당자들은 성수기에 휴가도 마음대로 못가기도 하였습니다. 성수기 이전에 개발해야 하는 일정으로 인해 짧은 기간 개발을 진행하였지만 특가 프로젝트가 끝난 후에는 영업실 담당자와 데이터 소싱 개발자는 더이상 비생산적인 활동을 계속 할 필요도 없었고 그분들은 그 이후 휴가를 마음껏 갈 수 있었습니다. 특가 기능은 1년이 지난 지금도 잘 운영되고 있으며 그 프로젝트는 제가 진행한 프로젝트 중 가장 보람이 있었고 기억에 남는 업무입니다.

동시성으로 인한 비관적 잠금 문제를 해결하는데 많은 고민을 할 수 있었습니다.

- 비관적 잠금이란 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 실행하고 변경을 처리하는 방식을 말합니다.
- Amazon의 Aurora DB는 기본 격리수준을 **REPEATABLE-READ**로 강제하고 있습니다. 강제하고 있다는 말은 변경이 가능하지 않았지만 Amazon Aurora MySQL 5.6 Release 1.22.0 Now Available 버전에서는 변경 가능합니다.
- read-committed : 조회 데이터에 대한 shared lock이 걸린다. commit이 이루어진 데이터가 조회된다.
- repeatable-read : transaction 내 조회한 데이터의 내용이 항상 동일함을 보장해 줍니다. 사용자1이 select 하는 동안 사용자2의 update는 commit할 수 없으며, insert는 commit할 수 있습니다. 사용자1의 select가 끝나면 update가 가능합니다.

특가가 배치스케줄에 의해 적용되는 동안 만약 그 상품을 누군가 조회하고 있었다면 **PessimisticLockingFailureException** 이 발생합니다. 이는 Transaction의 범위를 줄이는 것으로는 해결할 수 없습니다. 그래서 생각한 방법은 특가를 적용할 때 스케줄러를 통해 해당 행사의 데이터를 업데이트하는 것이 아닌 해당 행사에 특정 날짜 조건으로 데이터를 수정하는 것이 아닌 추가하는 방식으로 변경하였습니다. repeatable-read는 insert에 대한 commit은 다른 session에서 select시에도 가능하기 때문에 오류가 발생하는 문제를 해결할 수 있었고, 추가로 특가가 적용되는 시점의 차이가 발생하는 현상도 함께 해결할 수 있었습니다.

### 프로젝트 진행 시 의사 결정 기준이 무엇인가?

이전에는 의사결정에 가장 영향을 많이 받는 것이 기능 구현과 일정이었습니다. 하지만 현재는 의사결정 시 요구사항의 의도파악에 심혈을 기울이고 있으며 이러한 요구사항에 부합하는 기능이 현재 기능에 어떤 영향을 끼치는지를 함께 고려합니다.

### 서비스를 개선해 본 경험을 말해 달라.

사내 특가 서비스의 적용 방식을 개선하였습니다.

최초 개발된 특가 방식은 동시성으로 인해 **PessimisticLockingFailureException** 이 간헐적으로 발생하였습니다.

- 비관적 잠금이란 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 실행하고 변경을 처리하는 방식을 말합니다.
- Amazon의 Aurora DB는 기본 격리수준을 **REPEATABLE-READ**로 강제하고 있습니다. 강제하고 있다는 말은 변경이 가능하지 않았지만 Amazon Aurora MySQL 5.6 Release 1.22.0 Now Available 버전에서는 변경 가능합니다.
- read-committed : 조회 데이터에 대한 shared lock이 걸린다. commit이 이루어진 데이터가 조회된다.
- repeatable-read : transaction 내 조회한 데이터의 내용이 항상 동일함을 보장해 줍니다. 사용자1이 select 하는 동안 사용자2의 update는 commit할 수 없으며, insert는 commit할 수 있습니다. 사용자1의 select가 끝나면 update가 가능합니다.

특가가 배치스케줄에 의해 적용되는 동안 만약 그 상품을 누군가 조회하고 있었다면 **PessimisticLockingFailureException** 이 발생합니다. 이는 Transaction의 범위를 줄이는 것으로는 해결할 수 없습니다. 그래서 생각한 방법은 특가를 적용할 때 스케줄러를 통해 해당 행사의 데이터를 업데이트하는 것이 아닌 해당 행사에 특정 날짜 조건으로 데이터를 수정하는 것이 아닌 추가하는 방식으로 변경하였습니다. repeatable-read는 insert에 대한 commit은 다른 session에서 select시에도 가능하기 때문에 오류가 발생하는 문제를 해결할 수 있었고, 추가로 특가가 적용되는 시점의 차이가 발생하는 현상도 함께 해결할 수 있었습니다.

### 요즘 관심 있는 분야는 무엇인가?

Event Sourcing에 대해 공부하고 있습니다. 처음에 Event Sourcing의 개념을 접하고 공부하고자 하였을 때 제가 가진 지식으로는 완벽하게 그원리와 개념을 알기 힘들다고 판단했습니다. 그래서 2년이라는 목표를 잡고 Event Sourcing에 대해 알아가고자 현재는 디자인 패턴을 공부하고 있습니다. 디자인 패턴을 공부하고 개발에 적용하기 위해 TDD를 연습하고 있습니다. 추후 Reactive Programing과 Event Driven architecture에 대해 공부할 예정이며 이러한 지식을 기반으로 Event Sourcing에 대해 알아가고자 하는 계획을 가지고 있습니다.

### 매일매일 하고 있는 공부가 있나? 공부 이외 하고 있는 일은?

짧은 경력이지만 개발자로서 경력이 쌓여가면서 한글로 된 문서보다는 영어로 된 문서를 읽을 일이 더 많아졌습니다. 번역기를 사용해도 되지만 좀더 빠르고 맥락을 잘 이해하기 위해서 영어 독해공부를 매일 아침 공부하고 있습니다.
공부 이외에 매일 하는 일은 운동입니다. 지난 2년동안 수영을 배웠고 현재는 스피닝을 배우고 있습니다.

### 서버 장애에 대처해본 경험이 있는가?

2019년 초에 서비스가 점점 발전하면서 프로모션을 위한 마케팅 푸시를 보내 특정 시간 내 다수의 유저가 유입되면 서버가 다운되는 현상을 겪었었습니다.

장애원인은 분석결과 두가지의 원인이 발견되었습니다.

1. 조회 속도 개선을 위해 Elastic cache를 사용하였는데 master cache 서버에 다량의 데이터가 write되면서 발생한 문제

   우선 문제가 되는 cache서버는 장애상황을 해결하기 위해 재시작 하였고, cache 서버가 왜 다량의 데이터가 write 되는지에 대해 분석하기 시작하였고 발생한 원인은 이전에 잠시 개발되었다가 현재는 폐기되었던 기능 중 login 정보를 캐시하는 부분에서 발생한 문제로 확인되었습니다. 그래서 문제가 없다고 판단되는 cache write 부분들을 모두 제거하였습니다.

2. database pool의 크기가 기본값으로 되어 있는 문제

   database pool문제는 cahce 문제를 해결하고 나서 발생한 두번째 장애였는데요, 그동안 캐시로인한 장애에 묻혀서 발생하지 않았던 것으로 추측됩니다. 사용고객이 많지 않고 접속 요청이 많지 않을 평소에는 괜찮았지만 프로모션활동으로 인해 사용자가 몰리는 경우 응답시간이 급격하게 떨어지는 문제가 발생하였습니다. log를 확인해보니 connection pool의 최대값이 부족해서 발생한 문제로 확인되어 connection pool의 크기를 조정하였습니다. 부하 테스트는 ngrinder를 사용해 보았습니다. pool의 크기는 (cpu \* 2) + effect_spindle_count(RAID 개수)로 하였습니다.

### 디비 설계 및 도메인 디자인 경험이 있는가?

네 타임세일, 컨텐츠, 필터세트의 프로젝트 때 데이터베이스 설계 및 도메인 디자인 하였습니다.

### Thread와 Process의 차이점에 대해 설명해 보라.

- Process

  컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

- Thead

  Process 내에서 실행되는 여러 흐름의 단위

  Process는 1개 이상의 Thread를 가질 수 있습니다. 멀티프로세스 보다 멀티쓰레드로 작업을 실행하는 경우 자원을 할당하는 시스템 콜이 줄어들어 자원을 좀더 효율적으로 사용할 수 있습니다. 뿐만 아니라 프로세스간의 통신보다 쓰레드간의 통신이 비용이 적게들어 통신부담도 줄어듭니다. 하지만 멀티쓰레드의 경우 전역변수의 사용으로 인한 동기화 문제를 항상 고려해야 합니다.

### Java는 어느 정도 다루나?

전문가라고는 할 순 없지만, 요구사항에 맞는 기능을 제가 원하는 방식으로 다른사람의 도움없이 구현할 수 있습니다.

### 자바 스크립트의 특징은 무엇이라고 생각하나?

- 동적 형변환
- 프로토타입 기반 객체지향 (상속과 클래스 개념이 없음. ES5 기준)
- 실행시 평가
- 고차함수
- 인터프리터 언어

### 트래픽 과부하가 발생할 경우 어떻게 할 것인가?

과부하가 생기기전에 미리 예측할 수 있다면 가장 좋을 것이라 생각합니다. 예를 들면 대규모 마케팅 프로모션이 있을 예정이라면 예상되는 병목지점이라던가 어플리케이션에서 예상되는 문제가 없는지 체크하고 만약 서버과 해당 과부하를 견딜 수 없다면 scale-up이나 scale-out을 고려해 볼 것입니다.

DB에서 과부하가 발생한다면 문제가 심각해 질 수 있습니다. 이런 경우에는 Redis를 이용한 캐싱을 이용해 부하를 줄일 수 있는 지 검토해 볼 수 있을 것 같습니다.

### 최신 기술 트렌드를 어떤 방법으로 쫓아 가는가?

다른 개발자들과 지식 공유를 통해 최신 기술이나 이슈에 대한 정보를 얻습니다. 얻을 정보 중 가장 관심이 가는 주제 하나를 선정해서 구글링을 해서 좀더 많은 정보를 찾거나 더 깊이 알고 싶은 경우에는 책을 구입해서 읽으려 하고 있습니다.

### Lambda 식에 대해서 설명해 보라.

lambda 식별자 없이 실행 가능한 함수 표현식이라고 말할 수 있을 것 같습니다. 코드를 줄이고 가독성 향상에 목적을 두고 있습니다.

제가 가장 많이 사용하는 함수는 map, filter, flatmap, forEach, reduce 정도가 있습니다.

- map

개별 요소의 연산된 결과를 stream으로 반환합니다.

- filter

개별 요소에 조건을 적용하여 조건에 만족하는 요소로만 stream을 반환합니다.

- flatmap

stream 내부에 있는 개체들을 연결한 stream을 반환합니다.

- forEach

stream의 요소들을 순회합니다.

- reduce

stream을 단일 요소로 반환합니다.

### 생각나는 개발서에 대해서 인상 싶었던 부분을 이야기해보라.

저는 클린코드를 읽으면서 가장 와닿았던 것이 '작게'였습니다.
클린코드에서는 '함수를 작게 만들어라'와 '책임을 적게 가지도록 해라' 같은 구체적인 가이드라인을 제시하는 것 뿐만아니라 코드의 중복을 줄이고 디자인 패턴을 적용하며 다른사람의 읽는 시간을 줄이는 등의 "작음"을 추구하는 방법에 대한 가이드라인도 제시해 주었습니다. 그래서 저는 클린코드에서 가장 인상 깊었던 단어는 "작음"입니다.

### 사용해 본 디자인 패턴에 대해서 설명해 보라.

- Dependency Injection

  구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나입니다.
  의존성 주입과 항상 함께 나오는 단어가 inversion of control입니다. 의존 주입 시 구현체가 아닌 인터페이스를 주입한다면 종속성을 감소시키고 재사용성을 높일 수 있습니다. 테스트 코드를 작성하기에도 좋습니다.

  ```java
  class Controller {
     private Service service;

     public Controller(Service service) {
        this.service = service;
     }

     public void run() {
        service.do();
     }
  }

  interface service {
     public void do();
  }

  class serviceImpleA {
     public void do() {
        // ...
     }
  }

  class serviceImpleB {
     public void do() {
        // ...
     }
  }
  ```

- Decorator

  주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴입니다.

  ```java

  interface AuthProvider {
     public boolean isAuth(String id, String pw);
  }

  class OfficeAuthProvider implements AuthProvider {
     public boolean isAuth(String id, String pw) {
        boolean isAuth = false;
        // ... authorize logic
        return isAuth;
     }
  }

  class OfficeAuthProviderDecorator implements AuthProvider {

     private AuthProvider authProvider;

     public boolean isAuth(String id, String pw) {
        boolean isAuth = false;

        if (isDevelopIdentification(id, pw)) {
           isAuth = ture;
        } else {
           isAuth = authProvider.isAuth(id, pw)
        }

        return isAuth;
     }
  }

  ```

### 현재 자바 버전과 새롭게 추가된 기능?

현재까지 자바 버전은 13버전까지 나온 것으로 알고 있습니다.

- 자바 7

  - <> 지시자
  - switch문에서 String 클래스 사용
  - 자동 자원관리 - try () {} catch(Exception e) {}
  - multi-catch 기능 try {} catch(IlligalException e) {} catch(Exception e) {}

- 자바 8

  - 람다 표현식 추가
  - 스트림 API 추가
  - java.time 패키지 - LocalDate, LocalDateTime

- 자바 9
  - 불변 collection 생성 함수 추가 - List.of(), Map.of()
  - 자동 자원관리 개선
    ```java
    void tryWithResourcesByJava7() throws IOException {
       BufferedReader reader1 = new BufferedReader(new FileReader("test.txt"));
       try (BufferedReader reader2 = reader1) {
          // do something
       }
    }
    // final or effectively final이 적용되어 reader 참조를 사용할 수 있음
    void tryWithResourcesByJava9() throws IOException {
       BufferedReader reader = new BufferedReader(new FileReader("test.txt"));
    try (reader) {
          // do something
       }
    }
    ```
  - interface 내에서 private 함수 사용 가능
  - Reactive Stream API 추가
  - HTTP2 클라이언트 제공 - `jdk.incubator.http`
    ```java
    // 동기 호출
    HttpResponse response = HttpRequest
                   .create(new URI("http://www.ocado.com"))
                   .body(noBody())
                   .GET().send();
    int responseCode = response.responseCode();
    String responseBody = response.body(asString());
    System.out.println(responseBody);
    // 비동기 호출
    HttpRequest request = HttpRequest
                   .create(new URI("http://www.ocado.com"))
                   .body(noBody())
                   .GET();
    CompletableFuture<HttpResponse> future = request.sendAsync();
    Thread.sleep(10);
    if (!future.isDone()) {
       future.cancel(true);
       System.err.println("timeout");
       return;
    }
    HttpResponse response = future.get();
    ```
- 자바 10

  - 로컬변수를 `var`를 이용하여 선언
  - 가비지 컬렉터 인터페이스추가

- 자바 11

  - Nest 기반 접근 제어
  - 새로운 표준 HTTP 라이브러리 - `java.net.http`
  - 람다에서의 `var`변수 사용

- 자바 12

  - 스위치문 확장 (preview: --enable-preview 옵션을 줘야 사용가능)
    ```java
    switch (value) {
       case 1,2 -> System.out.println(a);
       case 3 -> System.out.println(b);
       case 4 -> System.out.println(c);
    }
    ```
  - 기타 성능향상

- 자바 13
  - 스위치문 확장 (preview: --enable-preview 옵션을 줘야 사용가능)
    ```java
    switch (value) {
       case 1,2 -> System.out.println(a);
       case 3 -> System.out.println(b);
       case 4 -> System.out.println(c);
    }
    ```
  - Text Blocks (preview: --enable-preview 옵션을 줘야 사용가능)

### String, StringBuilder, StringBuffer 차이점

1. String
   불변 개체이다. 그래서 새롭게 문자열이 생성될 때마다 메모리 공간이 변경되는 것이 아니라 새롭게 생성되므로 문자열 연산시 성능이 좋지 않다.
   문자열 연산이 적고 멀티쓰레드 환경에 사용하기 적합

2. StringBuffer
   동기화를 지원하기 때문에 Thread-safe하다.

3. StringBuilder
   동기화를 지원하지 않기 때문에 멀티쓰레드 환경에 사용하기에 적합하지 못하다. 연산처리가 StringBuffer보다 빠르다.

### 코틀린을 사용하면서 느꼈던 장점과 단점

- 장점

  - 코드가 간결해진다 -> 가독성이 좋아진다.
  - null safe하기 때문에 null pointer exception을 만날 확율을 많이 줄일 수 있다.
  - 자바와의 호환성이 좋기 때문에 자바에 익숙한 사람들이 코틀린을 사용하는데 러닝커브가 낮다.
  - extention function 지원
  - data 클래스
  - immutablity

- 단점

  - 순수 자바보다 패키지 사이즈가 커지는 경향이 있다.
  - 빌드 시간이 조금 느리다.

### javascript와 ES6의 차이점

ES6의 특징

- 기본 매개변수

  ```javascript
  // ES5
  var link = function (height, color, url) {
     var height = height || 50
     var color = color || 'red'
     var url = url || 'http://azat.co'
     ...
  }

  // ES6
  var link = function(height = 50, color = 'red', url = 'http://azat.co') {
  ...
  }
  ```

- 템플릿 리터럴

  ```javascript
  // ES5
  var name = "Your name is " + first + " " + last + ".";
  var url = "http://localhost:3000/api/messages/" + id;

  // ES6
  var name = `Your name is ${first} ${last}.`;
  var url = `http://localhost:3000/api/messages/${id}`;
  ```

- 멀티라인 문자열

  ```javascript
  // ES5
  var roadPoem =
    "Then took the other, as just as fair,\n\t" +
    "And having perhaps the better claim\n\t" +
    "Because it was grassy and wanted wear,\n\t" +
    "Though as for that the passing there\n\t" +
    "Had worn them really about the same,\n\t";

  var fourAgreements =
    "You have the right to be you.\n\
     You can only be you when you do your best.";

  // ES6
  var roadPoem = `Then took the other, as just as fair,
     And having perhaps the better claim
     Because it was grassy and wanted wear,
     Though as for that the passing there
     Had worn them really about the same,`;

  var fourAgreements = `You have the right to be you.
     You can only be you when you do your best.`;
  ```

- 비구조화 할당

  ```javascript
  // ES5
  var data = $("body").data(), // data has properties house and mouse
    house = data.house,
    mouse = data.mouse;

  // ES6
  var { house, mouse } = $("body").data();

  var [col1, col2] = $(".column"),
    [line1, line2, line3, , line5] = file.split("\n");
  ```

- 화살표 함수

  ```javascript
  // ES5
  var _this = this;
  $(".btn").click(function(event) {
    _this.sendData();
  });

  // ES6
  $(".btn").click(event => {
    this.sendData();
  });
  ```

- Promises

  ```javascript
  // ES5
  setTimeout(function() {
    console.log("Yay!");
  }, 1000);

  // ES6
  var wait1000 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 1000);
  }).then(function() {
    console.log("Yay!");
  });
  ```

- 블록 범위 생성자 Let 및 Const

  ```javascript
  // ES5
  var a = 1;

  // ES6
  let a = 1;
  const b = 2;
  ```

- Class

  ```javascript
  // ES5
  function User() {
    // ...
  }

  // ES6
  class User {
    // ...
  }
  ```

- Module

  ```javascript
  // ES5
  module.exports = {
  port: 3000,
  getAccounts: function() {
     ...
  }
  }
  var service = require('module.js')
  console.log(service.port) // 3000

  // ES6
  import {port, getAccounts} from 'module'
  console.log(port) // 3000
  ```

### 스프링의 버전별 차이점

- Spring 3

  - JAVA 5+ 지원
  - 전체 프레임워크를 여러개로 분리
  - SPEL 제공
  - REST API 지원 추가

- Spring 4

  - JAVA 8
  - Starter Pack 지원
  - Hibernate 3.6, Joda-Time 2.0 등 지원
  - 람다식, Optional 등 Framework 레벨에서 지원
  - REST방식 Controller 지원

- Spring 5
  - JAVA8을 표준으로 사용하며 8+ 버전 지원
  - Reactive Programing Model (WebFlux)
  - 함수형 프로그래밍 with Kotlin
  - Testing improvement (junit5 완벽지원, 병렬테스트 지원, Spring Webflux 테스트 지원)

### 스프링의 특징

1. 경량 컨테이너
2. IoC
3. DI
   구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나입니다.

4. AOP
   횡단 관심사(cross-cutting concern)의 분리를 허용함으로써 모듈성을 증가시키는 것이 목적인 프로그래밍 패러다임이다. 코드 그 자체를 수정하지 않는 대신 기존의 코드에 추가 동작(어드바이스)을 추가함으로써 수행하며, "함수의 이름이 'set'으로 시작하면 모든 함수 호출을 기록한다"와 같이 어느 코드가 포인트컷(pointcut) 사양을 통해 수정되는지를 따로 지정한다. 이를 통해 기능의 코드 핵심부를 어수선하게 채우지 않고도 비즈니스 로직에 핵심적이지 않은 동작들을 프로그램에 추가할 수 있게 한다. 관점 지향 프로그래밍은 관점 지향 소프트웨어 개발의 토대를 형성한다.

5. MVC
   Model, View, Controller로 구성된 모델을 말한다.

   - Model은 도메인과 같이 요구사항에 대한 기능 및 상태를 정의한 것이다.
   - View는 프리젠테이션을 담당하는 역할을 합니다.
   - Controller는 Model과 View의 중간 인터페이스 역할을 합니다.

   DispatcherServlet, HandlerMapping, ViewResolver가 있습니다.

   - DispatcherServlet: 사용자의 요청을 받아 처리하는 역할, 받은 요청을 HandlerMapping에게 넘겨준다.
   - HandlerMapping: 사용자의 요청을 처리한 Controller를 찾는 역할
   - ViewResolver: Controller가 반환한 결과를 표시할 개체를 찾는 역할

6. WAS에 독립적

7) POJO 기반의 구성
   일반적인 자바 코드로 스프링에 적용 가능합니다.

8) 트랜잭션 지원
   손쉽게 트랜잭션을 적용할 수 있어 트랜잭션에 대한 코드량을 줄일 수 있습니다.

### TDD에 대해 설명하라

테스트 주도 개발(Test-driven development TDD)은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나이다. 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다. 그런 후에, 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다. 마지막으로 작성한 코드를 표준에 맞도록 리팩토링한다.

### 스크럼과 칸반의 차이점에 대해 설명하라

- 스크럼
  스프린트를 기반으로 애자일 방법론을 실행하는 것을 말합니다. 스프린트 작업 단위를 부여하고 작업을 계획 실행 후 회고하는 방식으로 진행됩니다. 회고한 내용을 다음 스프린트에 반영하여 계속 진행하는 방식입니다. 짧은 개발 주기와 피드백을 추구합니다.
  주목할만한 특징중 하나는 Hot Fix는 현재 진행중인 스프린트에 절대 넣지 않는 것입니다.

- 칸반
  Work In Process를 제한하여 애자일 방법론을 실행합니다. 칸반의 특징은 스크럼과 달리 스프린트 기간이 정해지지 않는다는 것입니다. 이슈가 생기면 백로그에 쌓이게 되고 작업자는 작업할 여유가 되면 해당 카드를 자신에게 할당하여 in progress로 상태를 바꾸고 처리하는 방식으로 언제 그 일이 처리가 될지는 정해지지 않습니다. 중요한건 in progress의 상태를 가진 카드를 제한하는 것입니다. 백로그와 다르게 Hot Fix는 언제든지 백로그에 추가될 수 있고 우선순위에 따라 언제든지 프로젝트를 위한 카드보다 먼저 처리될 수 있습니다.

### Junit5의 특징

1. DisplayName
2. ParameterizedTest 용이성
3. @Nested를 이용한 중첩 구성
4. Exception 테스팅

### 리펙토링이란 무엇인가

'결과의 변경 없이 코드의 구조를 재조정함'을 뜻한다. 주로 가독성을 높이고 유지보수를 편하게 한다. 버그를 없애거나 새로운 기능을 추가하는 행위는 아니다. 사용자가 보는 외부 화면은 그대로 두면서 내부 논리나 구조를 바꾸고 개선하는 유지보수 행위이다.

저는 그래서 테스트 코드가 없는 리펙토링은 반쪽짜리 리펙토링이라고 생각합니다. 왜냐하면 결과의 변경이 없었다는 것을 보장해주는 테스트가 없으면 구조를 재조정한 후에 그 결과가 같다는 것을 보장할 수 없기 때문입니다.

### 속력과 속도의 차이가 무엇인가?

- 속력
  속력 은 여러분이 여행하는 데 들어간 시간과 여행한 거리의 관계, 즉 시간당 거리이다. 다른 말로 한다면 1초 동안에 몇 m를 이동 했는가를 나타낼 수 있는 것이다. 속력은 시간과 거리로 나타내 는 스칼라량이다. 여기에는 방향이 포함되지 않는다.

- 속도
  속도 는 거리,시간, 방향을 모두 나타내는 벡터량이다. 속도를 다르 게 설명한다면 속도는 1초동안에 처음 위치에서 얼마의 변화가 있느냐를 나타내는 값을 속도라고 한다. 속력과는 약간 다른 개 념으로 이해해야 한다. 자동차가 일정한 속력으로 직선을 달릴 때 속도는 일정하다. 자동차가 구불구불한 도로를 달릴 때 속력 은 일정해도 방향이 바뀌기 때문에 속도는 일정하다고 얘기할 수 없는 것이다.

### 기술블로그에서 가장 인상깊었던 글이 있는가?

저는 **도움이 될수도 있는 JVM memory leak 이야기**라는 글이 인상 깊었습니다. 메모리 누수에 대해 원인을 파악하기 위해 접근하는 방식이 아주 흥미로웠습니다. 원인을 파악하기 위해 하나의 가설을 세우고 그것을 확인한 후 다른 가설을 세워 결과를 도출해 내는 방식은 제가 글을 읽으면서 개발할 때 어떠한 태도를 가지면 좋을지에 대한 생각을 하게끔 해주었습니다.

### GIT REBASE에 대해 설명해보라

rebase란 GIT에서 하나의 브런치를 다른 브런치에 합치는 방법 중 하나입니다. 저는 주로 다른 브런치의 커밋을 현재 브런치로 병합을 할때나, interactive 옵션을 사용하여 기존에 작성하였던 커밋을 수정할 때 사용하였습니다.

위험성

- 리모트 브런치에 PUSH된 브런치를 Rebase 할때
- Rebase 한것을 다시 Rebase할때

### DB의 격리수준에 대해 설명해보라

- dirty-read : A 트랜잭션에서 레코드의 데이터를 1에서 2로 변경하고 아직 커밋하지 않았을때 B 트랜잭션에서 동일 레코드를 조회하면 조회한 데이터는 2가 될 것입니다. 이때 A 트랜잭션이 롤백이 실행되고 B 트랜잭션에서 조회한 데이터 2를 3으로 변경한다면 정상적이지 않은 변경일 수 있을 것입니다.

- non-repeatable-read : A 트랜잭션에서 데이터를 조회할 때 데이터가 1이었고, B 트랜잭션에서 해당 레코드의 데이터를 1에서 2로 변경이 발생하였다면 A 트랜잭션에서 데이터를 다시 조회하였을 때 조회된 데이터는 2가 됩니다. 그런데 B 트랜잰션에서 롤백이 발생하고 A 트랜잭션에서 데이터를 2에서 3으로 변경한다면 정상적으로 변경된 것이 아닐 수 있습니다.

- phantom-read : A 트랜잭션에서 1의 조건으로 데이터를 검색하였고, B 트랜잭션에서 1조건의 가진 데이터를 새롭게 추가/삭제/변경하는 경우, A 트랜잭션에서 1의 조건으로 데이터를 다시 검색하였을 때 B 트랜잭션에서 변경한 데이터를 조회할 수 있게 됩니다. 이때 B 트랜잭션에서 롤백을 실행한 후 A 트랜잭션에서 조회한 데이터를 변경하게 되면 해당 데이터들은 정상적인 변경이 아닐 수 있습니다.

아래로 내려갈수록 격리수준이 높아져 위에 언급한 문제가 발생할 가능성은 줄어들지만 동시 처리 성능은 떨어집니다.

- shared-lock : select에 대한 lock을 직접 걸지 않고 innoDB가 각 행에 대한 lock을 실행한다.
- exclusive-lock : update, delete에 대한 lock을 실행한다.

1. Read-Uncommitted
   트랜젝션의 변경내용이 commit이나 rolback 여부에 관계없이 다른 트랜잭션에서 보여집니다. 동시처리 성능이 가장 높습니다.
   dirty-read, non-repeatable-read, phantom-read

2. Read-Committed
   어떤 트랜잭션에서 데이터의 변경이 일어나도 commit이 완료된 데이터만 조회 가능합니다.
   non-repeatable-read, phantom-read

3) Repeatable-Read
   트랜잭션 내 조회한 데이터의 내용이 항상 동일함을 보장해 줍니다.
   phantom-read

4) Serializable
   트랜잭션 내 조회한 데이터의 내용이 항상 동일하며 다른 트랜잭션에서의 변경 또한 불가능합니다.
   dead-lock

### 코들린의 functions

1. let (lambda)

- 콜체인 결과에 대해 하나 이상의 기능을 호출하는데 사용됩니다.
  ```kotlin
  val numbers = mutableListOf("one", "two", "three", "four", "five")
  numbers.map { it.length }.filter { it > 3 }.let {
     println(it)
     // and more function calls if needed
  }
  ```
- let은 null 이 아닌 코드 블록에서 자주 사용되기도 합니다.
  ```kotlin
  val str: String? = "Hello"
  //processNonNullString(str)       // compilation error: str can be null
  val length = str?.let {
     println("let() called on $it")
     processNonNullString(it)      // OK: 'it' is not null inside '?.let { }'
     it.length
  }
  ```
- 코드의 가독성의 위해서도 사용됩니다.
  ```
  val numbers = listOf("one", "two", "three", "four")
  val modifiedFirstItem = numbers.first().let { firstItem ->
     println("The first item of the list is '$firstItem'")
     if (firstItem.length >= 5) firstItem else "!" + firstItem + "!"
  }.toUpperCase()
  println("First item after modifications: '$modifiedFirstItem'")
  ```

2.  with (receiver)

- 해당 오브젝트의 다음 행위를 정의할때 사용됩니다.

  ```kotlin
  val numbers = mutableListOf("one", "two", "three")
  with(numbers) {
     println("'with' is called with argument $this")
     println("It contains $size elements")
  }
  ```

- 속성이나 기능이 값을 계산하는데 사용될 도우미 역할을 합니다.

  ```kotlin
  val numbers = mutableListOf("one", "two", "three")
  val firstAndLast = with(numbers) {
     "The first element is ${first()}," +
     " the last element is ${last()}"
  }
  println(firstAndLast)
  ```

3. run (receiver)

- `let`과 같은 동작합니다. 단지 receive를 사용하냐 lambda를 사용하냐의 차입니다.

- 개체 초기화와 계산의 결과를 함께 포함한 함수에 주로 사용됩니다.

  ```kotlin
  val service = MultiportService("https://example.kotlinlang.org", 80)

  val result = service.run {
     port = 8080
     query(prepareRequest() + " to port $port")
  }

  // the same code written with let() function:
  val letResult = service.let {
     it.port = 8080
     it.query(it.prepareRequest() + " to port ${it.port}")
  }
  ```

- 비확장 기능으로 사용되기도 합니다.

  ```kotlin
  val hexNumberRegex = run {
     val digits = "0-9"
     val hexDigits = "A-Fa-f"
     val sign = "+-"

     Regex("[$sign]?[$digits$hexDigits]+")
  }

  for (match in hexNumberRegex.findAll("+1234 -FFFF not-a-number")) {
     println(match.value)
  }
  ```

4. apply (receiver)

- 값을 반환하지 않고 receiver 개체의 맴버변수에 대한 기능을 수행할때 사용됩니다.

- 일반적인 사용은 "개체에 특정 요구사항을 적용하라"와 같은 개체에 대한 설정 적용입니다.

  ```kotlin
  val adam = Person("Adam").apply {
     age = 32
     city = "London"
  }
  println(adam)
  ```

5. also (lambda)

- `로깅`이나 `표시`와 같이 값을 변경하지 않는 추가적인 작업을 할때 사용됩니다. 즉 제거되어도 콜체인의 논리가 깨지지 않는 호출을 말합니다.

  ```kotlin
  val numbers = mutableListOf("one", "two", "three")
  numbers
     .also { println("The list elements before adding new one: $it") }
     .add("four")
  ```

## 궁금한점?

### 50명에서 120명이 넘는 개발 인력이 짧은 시간에 채용되었을 때 발생했던 문제점과 어떻께 해결하였는지?

### 기술 부채를 해결하기 위해서 어떤 활동을 하셨는지?

### 개발자들이 사용하는 장비와 도서 지원 등 사내 지원 범위

### 현재 내가 지원하는 팀의 개발 문화와 역할

### 입사지원서에 대한 평가를 부탁해도 되는지?

## 자기소개

안녕하세요. 이번에 입사지원하게된 남경호 입니다. 저는 3가지 '호'를 가지고 있습니다.
첫번째는 성실함입니다. 이전 회사에서 가장 먼저 출근하는 직원중 한명이었고, 현재 재직중인 회사에서도 8시 출근이 생기기 이전에는 가장 먼저 출근하는 직원 중 한명이었습니다. 현재는 아침에 출근전에 매일 영어공부를 하고 있으며 퇴근 후에도 운동과 공부를 꾸준히 이어가고 있습니다.
둘째는 약속을 잘 지킵니다. 저는 아무리 작은 약속이라도 약속은 중요하다고 생각합니다. 상대방에게 신뢰가 있어야 함께 일하고 싶은 마음이 생긴다고 생각합니다. 저는 그런 신뢰를 무엇보다 중요하게 생각하기 때문에 반드시 지킬 수 있는 약속을 하며 그 약속은 무슨일이 있어도 지키고자 노력합니다.
셋째는 적응력입니다. 사실 저는 변화를 즐기는 편은 아닙니다. 하지만 변화가 필요하다면 누구보다 빠르게 적응하여 그 변화에 대한 부작용을 줄이고자 노력합니다. 이러한 적응력은 만약 제가 우아한 형제들의 구성원이 되더라도 빠르게 적응하여 필요한 인력이 될 수 있을 것입니다.

## 마지막 할말

## 참고

2차면접에서 중점적으로 보는 우아한형제들의 인재상은 크게 4가지다. △근면성실 △새시대 새일꾼 △근검절약 △배려와 협동이다.
‘근면성실’ 조항은 부지런하고 정성스럽게 일한다는 뜻이다. 김도형 인사담당자는 “회사가 근면 성실이라는 인재상을 설명할 때는 묵묵히 일하는 거북이가 잔꾀 많은 토끼를 결국 이긴다는 비유를 한다”고 말했다. 일할 때 요행을 바라기보다 정직하고 진실하게 임하는 사람을 뽑는다는 것이다.

‘새시대 새일꾼’은 새 시대 흐름을 파악해 시장이 어떤 방향으로 가는지 끊임없이 연구하는 인재다. 스타트업은 특성상 빠르게 변화하는 환경에 대비해야 한다. 고객만족을 위해 시대 흐름을 주도하고 새로운 기술을 확보하고 역량을 길러내야 한다.

‘근검절약’은 검소하고 아끼는 마음가짐과 태도를 가진 인재라는 뜻이다. 씀씀이를 아껴 남긴 것을 사회로 환원하자는 의미를 갖고 있다.

‘배려와 협동’은 함께 협업해 성과를 만들어내자는 뜻이다. 동료를 배려하고 주위에 긍정적인 에너지를 전할 수 있는 인재를 찾는다. 이 가치는 회사 창업자가 몸소 실현하고 있기도 하다. 우아한형제들 김봉진 대표는 우리나라에서 가장 많은 기부를 한 사람이다. 올해 3월 기준 개인으로 총 71억원을 기부했다. 그는 과거 한 인터뷰에서 “나 자신의 이익보다 사회를 생각하는 마음으로 베풂을 실천한다”고 밝혔다.
