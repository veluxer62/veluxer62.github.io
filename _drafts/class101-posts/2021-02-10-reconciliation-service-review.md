---
layout: single
title: "결제 대사 서비스 개발 리뷰"
categories:
  - POST
---

# 배경

현재 클래스 101 거래 정보와 나이스페이의 대사 작업을 수기로 하고 있어 자동화된 대사 시스템 개발로 불필요한 리소스를 줄이고 신뢰성 있는 대사 작업을 하기 위해 기능을 개발한다.

# 요구사항

매일 자동으로 전날의 대사 결과를 Slack으로 알려 준다.

클래스101과 나이스페이의 거래 정보가 일치하는 경우 성공 알림을 일치하지 않는 경우 거래ID와 함께 실패 알림을 전송한다.

# 다이어그램

## 협력 다이어그램

![reconciliation-co-diagram](/assets/images/draft/class101-posts/reconciliation-co-diagram.png)

## 클래스 다이어그램

![reconciliation-class-diagram](/assets/images/draft/class101-posts/reconciliation-class-diagram.png)

# 코드리뷰

[](https://github.com/pedaling/class101-payment-service-java)

# 진행상황

- [x]  클래스101의 거래정보를 가진 CSV 파일을 조회하여 나이스페이 거래정보와 비교한 후 콘솔창에 결과를 표시한다.
- [x]  클래스101의 거래정보를 CSV 파일로 조회하는 것에서 DB정보를 조회하는 것으로 대체한다.
- [x]  대사 결과 알림을 콘솔창에 표시하는 것에서 슬렉 알림으로 대체한다.
- [x]  배치 컨트롤러를 추가하여 자동으로 매일 대사 기능을 수행하도록 기능을 추가한다. (별도 배치 앱이 API를 호출하는 방식으로 변경되어 작업 불필요)

# 테스팅

## 단위 테스팅

소프트웨어의 가장 작은 단위 코드를 테스트하는 기법이다. 주로 클래스가 외부에 노출하는 함수를 테스트 대상이다. 일반적으로 하나의 테스트 대상에 세부적인 논리 별로 테스트 케이스를 작성한다.

장점

- 빠른 피드백을 기대할 수 있다.
- 테스트 하고자 하는 대상에만 집중할 수 있다.
- ~~테스트를 위한 준비 코드의 양을 줄일 수 있다~~. (테스트 케이스마다 다를 수 있다.)

단점

- GUI 계층에는 적용하기 쉽지 않다.
- 통합된 기능에 대한 안정성을 보장 해주지 않는다.

## 기능 테스팅

구현에 대해서는 관심을 가지지 않고 사용자가 특정 기능을 수행한 후 원하는 결과를 얻을 수 있는 지에 대한 테스트이다. 기능 테스트는 어플리케이션이 실행 되면서 자동화된 테스트를 수행하는 방식이다.

장점

- 단위테스트가 검출하지 못하는 전체 시스템, 환경에서 발생하는 문제점을 검출한다.
- 사용자가 원하는 충분한 성능에 대한 테스트가 가능하다.

단점

- 피드백이 단위 테스팅에 비해 느리다.
- 테스팅시 고려해야 할 사항이 많다. (시스템환경, 방화벽, 외부API 등)
- ~~테스트를 수행하기 위한 준비작업이 많다.~~ (테스트 케이스마다 다를 수 있다.)

## 그 외 테스팅 기법

### 통합 테스팅

둘 이상의 시스템 구성요소가 통합되었을 때 기능이 정상적으로 동작하는 지 검사하는 테스트 기법이다.

### 승인 테스팅

어플리케이션이 사용자가 요구한 기능을 정상적으로 수행하는 지 테스트하는 기법이다. 기능 테스팅과 다른 점은 승인테스팅은 자동화가 필수가 아니다.

## 테스팅 기법 선정 기준

대사 기능 구현 시 **단위 테스팅** 기법을 선정하여 코드를 작성하였다. 선정 사유는 아래와 같다.

### 외부인터페이스와의 연동

외부 API와 연동하는 경우 테스트 난이도는 크게 증가한다. 왜냐하면 외부 API는 제공해주는 값과 네트워크 환경 등 많은 요인으로 인해 테스트가 실패할 가능성이 높기 때문이다. 그래서 주로 도입하는 방법이 테스트 더블을 이용한 테스트 방법인데, 여기서는 Mock 객체를 이용하여 테스트를 하였다.

### 빠른 피드백

오랜만에 Java로 개발하다 보니 기능 구현에 대한 신뢰성을 가지고 개발하기 어려웠다. 그래서 내가 작업하는 코드가 제대로 작동하는 지 빠르게 확인하는 것이 중요하였다.

### GUI 계층

기능 구성도를 보면 대사 결과를 알려주는 알리미가 존재하는 것을 볼 수 있다. 알리미는 GUI계층인 데 GUI계층의 경우 기능 테스트가 용이하지 않다. 예를 들면 슬렉으로 메시지를 전송 하였는데 정상적으로 슬렉에 전송되었는 지 확인하려면 눈으로 보는 방법 말고는 Slack API를 사용해야 하는데, 이 점은 테스트로 얻는 안정감보다 구현에 대한 공수가 훨씬 크게 들어서 과감하게 포기해야 하는 부분이라 생각하였다.

추가로 GUI 계층과 같이 사용자 요구에 의해 자주 변경되는 코드는 테스트 코드를 엄격하게 작성하지 않는데, 일례로 Front End에서 테스트 코드 작성 시 Model에 대한 코드는 엄격하게 작성하는 반면 View와 관련한 테스트 코드는 엄격하게 작성하지 않는 경향을 보인다.

# 느낀점

## 오랜만이야! JAVA

오랜만에 자바 코드로 기능을 개발하였다. 이전에는 JAVA 7로 개발을 했었는데, JAVA 11로 개발을 하니 새로운 함수들과 변수 선언은 신선함과 새로움에 대한 즐거움을 안겨 주었다. 빨리 적응 해서 생산성을 높여야겠다.

## Lombok + Jackson

외부 API와 통신하기 위해 Lombok이 선언된 DTO 객체에 Jackson을 이용하여 직렬화 및 역직렬화 하였다. 이때 Lombok의 잘못된 사용과 Jackson의 역직렬화 방식에 대한 이해가 부족하여 꽤 고생하였다. Jackson을 이용한 역직렬화 시에 final 변수를 사용할 수 있는 방법을 알고 계시면 공유 바랍니다ㅠ (굽신굽신)

## 섣부른 추상화

기능을 구현할 때 너무 섣불리 인터페이스를 정의하였다. 인터페이스는 발견되는 것인데 너무 섣부르게 추상화를 한게 아닌가 싶다. (~~코드를 잘 작성하고 싶은 욕심도 있었다.~~) 좋은 설계는 많은 경험을 통해서 나오는 것이라 생각한다. 앞으로 기능 구현 시 많이 조언을 구하고 고민을 해보아야 하겠다.

## 테스팅의 트레이드오프

위에도 언급했지만 단위 테스트는 통합된 기능에 대한 안정성을 보장해 주지 않는다. 그래서 시스템의 안정성을 위해서 통합 테스팅을 단위 테스팅과 함께 병행 하기도 한다. 시스템의 안정성을 가장 높일 수 있는 방법은 기능 테스팅을 수행하는 방법일 것이다. 하지만 그만큼 테스트 코드가 많아지고 속력은 떨어질 수 밖에 없을 것이라 생각한다. 테스팅 방법을 선택하는 것에 대해서는 다함께 논의하는 시간을 가지면 유익할 것 같다.

# Q/A

## Enum클래스에서 fromCode가 존재하는 이유?

```java
@Getter
@RequiredArgsConstructor
public enum StateCode {
    APPROVED("0"),
    BEFORE_CANCELED("1"),
    AFTER_CANCELED("2");

    private final String code;

    @JsonCreator
    public static StateCode fromCode(String code) {
        return Arrays.stream(StateCode.values())
                .filter(it -> it.code.equals(code))
                .findFirst()
                .orElseThrow();
    }
}
```

Enum 클래스에서 기본적으로 `valueOf(String name)`함수를 제공해 주는데 여기에서 `name`은 Enum의 열거값을 의미하기 때문에 위의 예제 처럼 json값에서 Enum의 코드 값을 매칭할 수 없어서 `fromCode`라는 함수를 추가하고 `@JasonCreator` 어노테이션을 추가하여 역직렬화 되도록 해주었습니다.

```java
@Test
public void test() {
    final var actual = StateCode.valueOf("APPROVED");
    assertThat(actual).isEqualTo(StateCode.APPROVED);
}
```

Json 예제는 아래와 같습니다.

```json
{
	"stateCode": "0"
}
```

## 인터페이스는 발견되는 것이다?

이번 발표에서 가장 논란의 여지가 많은 키워드였다고 생각합니다 ㅠㅠ 제가 생각없이 논란의 여지가 있는 문장을 말씀드린게 아닌가 생각이 드네요.

일단 인터페이스를 생성하고 그 인터페이스를 구현한 클래스를 생성하는게 좋은 설계 방향이라는 건 누구도 부정할 수 없는 사실이라 저도 생각합니다.

그리고 개발자가 요구사항에 대한 지식과 경험이 풍부하다면 인터페이스를 당연히 생성한 후 구현체를 만들어나가야 유연한 설계를 할 수 있다고 생각합니다.

다만 TDD로 개발할때, 특히 개발자 자신이 어떻게 설계해야할 지 명확히 알지 못하는 상황에서는 섣부른 인터페이스 정의로 시작하기 보다 TDD 사이클에서 리펙토링을 하면서 인터페이스를 발견해서 정의를 하는 것이 좋아 보입니다. 그래서 인터페이스는 발견되는 것이라고 말씀 드렸던 것입니다. 제가 발표 당시에 다소 모호하게 답변드렸던것 같아서 죄송스럽네요 ㅠㅠ 좀더 공부하겠습니다. 이부분은 제 개인 의견입니다.

제가 참고했던 자료 출처도 함께 공유드립니다! 일반적인 원칙은 아닙니다! (클린아키텍쳐가 아니엇네요😭)

[http://www.codemanship.co.uk/parlezuml/blog/?postid=934](http://www.codemanship.co.uk/parlezuml/blog/?postid=934)

반대 의견은 언제나 환영합니다! 이런 주제에 대해서는 언제든 논의하면 좋은 시간이 될거 같습니다 😁

## Unit 테스트에서 Mock 객체를 사용하는데 실제와 다르게 동작하는 경우?

예를 들어 DB repository 객체를 Mock을 사용하여 Unit 테스트를 진행 하였는데, 실제 DB에서 변경 사항이 발생하는 경우 코드에는 반영되지 않기 때문에 오류에 대한 검증이 안되지 않나?

맞습니다. 그런 경우에 검증 하기가 쉽지 않습니다. 그래서 기능 테스트가 필요한 이유이기도 합니다. 완전한 TDD를 위해서는 꼭 수행해야 하기도 하구요!

하지만 테스트 커버리지를 100%로 맞추기는 쉽지 않은 작업이며 우리의 속도에 맞추기에는 힘들수도 있습니다. 그래서 운영 부서에서 요구하는 요구사항을 TDD를 이용하여 도메인 모델로 표현하는데 집중하는게 더 좋다고 생각합니다. 요구사항은 언제든지 바뀔 수 있고 도메인 코드가 변경 되었을때 자동화된 테스트가 잘 알려준다면 우리는 손쉽게 요구사항을 수정하고 리펙토링 할 수 있을 것입니다. 그래서 저는 인프라적인 부분에 대한 테스트 검증은 어느정도 포기하고 도메인에 대한 비지니스 로직에 집중하여 테스트를 하는게 어떨까 하는 생각을 가지고 있습니다.

우리가 점점더 테스팅에 익숙해지고 숙련도가 높아진다면 통합테스팅과 기능테스팅에 대한 도전을 하는것으로 점점 확장해가면 어떨까 생각합니다😃 함께 공부하고 고민하고 논의해가면 너무 감사하고 행복할 것 같아요🙏

혹시 더 좋은 의견이나 궁금한 점이 있으시면 언제든지 물어봐 주세요!😁