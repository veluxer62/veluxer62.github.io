---
layout: single
title: "당근마켓 화상 면접 준비"
categories:
  - INTERVIEW
tags:
  - 당근마켓
---

## 자기소개

안녕하세요. 이번에 당근마켓에 개발자로 입사지원한 남경호 입니다. 저는 지난 개발경력 동안 API 서버, Back-Office 서버, Batch 서버등 백앤드 서버개발에 대한 개발 경험을 가지고 있습니다.

처음 재직한 닉스테크라는 회사는 보안관련 솔루션을 판매하는 회사였습니다. 그곳에서 보안관제용 Back-Office 기능개발과 대시보드, 배치서비스, 보고서 및 Splunk, Archsight, Qradar와 같은 SIEM 장비 연동과 관련한 기능 개발을 담당하였습니다. 주로 데이터 연동과 저장된 데이터를 시각화 하는 부분을 집중적으로 개발하였습니다.

현재 재직중인 엑스트라이버라는 회사는 트립스토어라는 여행패키지 상품 가격 비교 플랫폼 서비스를 운영하고 있는 회사입니다. 주로 클라이언트를 위한 API 개발과 Back-office 및 배치 서비스 개발을 담당하였고, 현재는 B2B 사이트를 위한 API 개발을 담당하고 있습니다.
엑스트라이버에서는 API의 속도 및 다량의 데이터를 어떻게 다룰지, 어떻게 API를 설계하면 좋은지를 고민하며 개발을 진행하고 있습니다.

저는 당근마켓에서 제가 가진 이러한 역량을 잘 발휘하여 서비스를 발전시킬 수 있는 개발자가 될 수 있다고 자신합니다.

## 지원동기

당근마켓이 일하는 방식을 보고 정말 함께 일해보고 싶다라는 생각을 가지게 되었습니다. 저는 목록을 나열할때 가장 중요하게 생각하는 부분이 1번이라고 생각합니다. 당근마켓이 일하는 방식 중 1번은 "스스로 업무를 선택해요"라는 말이었습니다. 그만큼 업무에 대한 적극성을 중요시하고 자율성이 높다는 말로 이해를 하였습니다. 저는 일을 할때 자발성이 중요하다고 생각합니다. 그래야 내가 더 일을 잘할 수 있고 좀더 나아지기 위해 노력하니까요. 저는 이곳에서 제가 잘할 수 있는 일을 적극적으로 발휘하며 함께 성장해 나가고 싶다는 생각을 하게 되었고 그래서 지원하게 되었습니다.

## 이직사유

새로운 백엔드 개발환경과 마이크로 서비스 아키텍쳐에 대해 배우고 싶어서 이직을 결심하게 되었습니다. 현재 재직 중인 회사에서는 아직 마이크로 서비스에 대한 기반이 마련되지 않았고 짧지 않은 시간동안 개발 조직이 경직된 상황이 지속되고 있습니다. 이러한 상황에서 나름대로 혼자 공부를 하며 새로운 환경으로 백엔드 서비스를 개발해보고 공부해보았지만 혼자만으로는 부족하다고 느끼고 있어 이직을 결심하게 되었습니다.

## 유연한 코드란?

유연한 코드란 누구나 그 코드를 읽어도 그 코드가 어떤 책임을 가지고 동작하는지 알 수 있고 변경에 대한 두려움이 없는 코드를 저는 유연한 코드라고 생각합니다.

## 일라스틱 서치에서 수정에 대한 처리는 어떻게 하나?

현재 트립스토에서는 AWS에서 제공하는 일라스틱 서치 서비스를 이용하여 일라스틱 서치를 사용하고 있습니다. 크롤링 서버나 API 서버에 의해서 상품데이터가 추가 또는 변경되면 일라스틱 서치에게도 갱신요청을 보내는 방식으로 사용하고 있습니다. 제가 알기로는 이러한 방법은 일라스틱 서치가 1000만건 이상의 수많은 데이터를 다룰 경우 성능 이슈가 발생할 수 있고 이를 해결하기 위해서 새로운 인덱스를 생성하고 교체해 주는 방식으로 검색엔진의의 성능을 최적화 하는 것으로 알고 있습니다. 하지만 저희가 다루는 상품의 개수는 해당 방식을 고려할 만큼 많지가 않고 실시간으로 인덱스를 유지할 필요성이 있어 현재까지는 실시간으로 인덱스를 갱신해주는 방식을 사용하고 있습니다.

## SVN과 GIT의 차이점

SVN과 GIT의 가장 큰 차이점은 GIT은 개발자가 자신만의 커밋 히스토리를 가질 수 있고 SVN은 그럴 수 없다는 것입니다. 이것은 commit한 작업을 개발자가 원하는 순간에 할 수 있는가, 원하는 순간에 머지할 수 있는가의 차이이기 때문에 개발자가 유연하게 소스를 관리할 수 있다는 점이 큰 차이라고 생각합니다.

## ORM의 장단점

장점

- 개발자가 SQL에 대한 전문적인 지식이 부족해도 최적화된 쿼리를 제공해준다.
- 객체지향적인 코드로 테이블 구조에 맞춘 코드를 작성하지 않으므로 직관적인 코드를 작성할 수 있다.
- 유지보수성이 좋다.

단점

- 복잡도에 따라 구현 난이도가 많이 증가한다.
- 잘못된 구현은 성능에 많은 영향을 끼칠 수 있다.
- 통계쿼리의 경우 ORM으로 구현하기 어려울 수 있다.

## 예약시 가격 변경에 대한 대처법

예약요청 정보에서 가격을 전송하여 현재의 가격과 전송된 가격을 비교하여 동일한 경우 예약프로세스를 진행하고 동일하지 않은 경우 예약 실패응답을 반환한다.

## 동시성 문제 해결방법

상품 데이터의 경우 크롤러, API, 관리자 등 많은 곳에서 수정요청이 발생하고 동시에 발생할 가능성이 존재하였습니다.
저희는 이러한 동시성을 해결하기 위해 아래와 같은 방식을 선택하였습니다.

하나는 수정요청에 대한 이력을 기록하고 실패한 요청에 대해서는 재시도를 하도록 하는 기능으로 해당 문제를 해결하고자 하였습니다. 해당 방법은 최종일관성은 보장하지만 필요한 시점에 데이터가 꼭 변경되어야 하는 경우에는 사용할 수 없었습니다.

또다른 하나는 특가시스템에서 적용한 방식인데요, 처음 특가시스템을 구현하였을 때에는 특가정보를 업데이트 하는 방식으로 구현하였었는데요, DB 업데이트인 경우 동시성 문제가 발생할 가능성이 있었고 이를 해결하기위해 특가정보를 무조건 등록만 하도록 하고 데이터를 조회 시 조건에 맞는 가격이 노출되도록 기능을 변경하여 해결하였습니다.

### 요즘 관심 있는 분야는 무엇인가?

최근 비동기 프로그래밍과 CQRS에 대해 많은 관심을 쏟고 있습니다. CQRS는 동시성을 해결하고자 하는 노력에서 좀더 깊이 공부하고 실무에 적용하면 좋을 것 같아 공부하고 있는데요, 해당 기능을 구현할 때 비동기 프로세스로 기능을 구현할 필요가 있어서 비동기로 서버를 구현하는 방법에 대해서도 공부하고 있습니다.

### Thread와 Process의 차이점에 대해 설명해 보라.

- Process

  컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

- Thead

  Process 내에서 실행되는 여러 흐름의 단위

  Process는 1개 이상의 Thread를 가질 수 있습니다. 멀티프로세스 보다 멀티쓰레드로 작업을 실행하는 경우 자원을 할당하는 시스템 콜이 줄어들어 자원을 좀더 효율적으로 사용할 수 있습니다. 뿐만 아니라 프로세스간의 통신보다 쓰레드간의 통신이 비용이 적게들어 통신부담도 줄어듭니다. 하지만 멀티쓰레드의 경우 전역변수의 사용으로 인한 동기화 문제를 항상 고려해야 합니다.

### 사용해 본 디자인 패턴에 대해서 설명해 보라.

- Dependency Injection

  구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나입니다.
  의존성 주입과 항상 함께 나오는 단어가 inversion of control입니다. 의존 주입 시 구현체가 아닌 인터페이스를 주입한다면 종속성을 감소시키고 재사용성을 높일 수 있습니다. 테스트 코드를 작성하기에도 좋습니다.

- Decorator

  주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴입니다.

### String, StringBuilder, StringBuffer 차이점

1. String
   불변 개체이다. 그래서 새롭게 문자열이 생성될 때마다 메모리 공간이 변경되는 것이 아니라 새롭게 생성되므로 문자열 연산시 성능이 좋지 않다.
   문자열 연산이 적고 멀티쓰레드 환경에 사용하기 적합

2. StringBuffer
   동기화를 지원하기 때문에 Thread-safe하다.

3. StringBuilder
   동기화를 지원하지 않기 때문에 멀티쓰레드 환경에 사용하기에 적합하지 못하다. 연산처리가 StringBuffer보다 빠르다.

### 코틀린을 사용하면서 느꼈던 장점과 단점

- 장점

  - 코드가 간결해진다 -> 가독성이 좋아진다.
  - null safe하기 때문에 null pointer exception을 만날 확율을 많이 줄일 수 있다.
  - 자바와의 호환성이 좋기 때문에 자바에 익숙한 사람들이 코틀린을 사용하는데 러닝커브가 낮다.
  - extention function 지원
  - data 클래스
  - immutablity

- 단점

  - 순수 자바보다 패키지 사이즈가 커지는 경향이 있다.
  - 빌드 시간이 조금 느리다.
  - 스프링 프레임워크에 한정되긴 하지만 레퍼런스가 많지 않습니다.

### 스프링의 버전별 차이점

- Spring 3

  - JAVA 5+ 지원
  - 전체 프레임워크를 여러개로 분리
  - SPEL 제공
  - REST API 지원 추가

- Spring 4

  - JAVA 8
  - Starter Pack 지원
  - Hibernate 3.6, Joda-Time 2.0 등 지원
  - 람다식, Optional 등 Framework 레벨에서 지원
  - REST방식 Controller 지원

- Spring 5
  - JAVA8을 표준으로 사용하며 8+ 버전 지원
  - Reactive Programing Model (WebFlux)
  - 함수형 프로그래밍 with Kotlin
  - Testing improvement (junit5 완벽지원, 병렬테스트 지원, Spring Webflux 테스트 지원)

### TDD에 대해 설명하라

테스트 주도 개발(Test-driven development TDD)은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나이다. 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다. 그런 후에, 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다. 마지막으로 작성한 코드를 표준에 맞도록 리팩토링한다.

### 스크럼과 칸반의 차이점에 대해 설명하라

- 스크럼
  스프린트를 기반으로 애자일 방법론을 실행하는 것을 말합니다. 스프린트 작업 단위를 부여하고 작업을 계획 실행 후 회고하는 방식으로 진행됩니다. 회고한 내용을 다음 스프린트에 반영하여 계속 진행하는 방식입니다. 짧은 개발 주기와 피드백을 추구합니다.
  주목할만한 특징중 하나는 Hot Fix는 현재 진행중인 스프린트에 절대 넣지 않는 것입니다.

- 칸반
  Work In Process를 제한하여 애자일 방법론을 실행합니다. 칸반의 특징은 스크럼과 달리 스프린트 기간이 정해지지 않는다는 것입니다. 이슈가 생기면 백로그에 쌓이게 되고 작업자는 작업할 여유가 되면 해당 카드를 자신에게 할당하여 in progress로 상태를 바꾸고 처리하는 방식으로 언제 그 일이 처리가 될지는 정해지지 않습니다. 중요한건 in progress의 상태를 가진 카드를 제한하는 것입니다. 백로그와 다르게 Hot Fix는 언제든지 백로그에 추가될 수 있고 우선순위에 따라 언제든지 프로젝트를 위한 카드보다 먼저 처리될 수 있습니다.

### 리펙토링이란 무엇인가

'결과의 변경 없이 코드의 구조를 재조정함'을 뜻한다. 주로 가독성을 높이고 유지보수를 편하게 한다. 버그를 없애거나 새로운 기능을 추가하는 행위는 아니다. 사용자가 보는 외부 화면은 그대로 두면서 내부 논리나 구조를 바꾸고 개선하는 유지보수 행위이다.

저는 그래서 테스트 코드가 없는 리펙토링은 반쪽짜리 리펙토링이라고 생각합니다. 왜냐하면 결과의 변경이 없었다는 것을 보장해주는 테스트가 없으면 구조를 재조정한 후에 그 결과가 같다는 것을 보장할 수 없기 때문입니다.

### 속력과 속도의 차이가 무엇인가?

- 속력
  속력 은 여러분이 여행하는 데 들어간 시간과 여행한 거리의 관계, 즉 시간당 거리이다. 다른 말로 한다면 1초 동안에 몇 m를 이동 했는가를 나타낼 수 있는 것이다. 속력은 시간과 거리로 나타내 는 스칼라량이다. 여기에는 방향이 포함되지 않는다.

- 속도
  속도 는 거리,시간, 방향을 모두 나타내는 벡터량이다. 속도를 다르 게 설명한다면 속도는 1초동안에 처음 위치에서 얼마의 변화가 있느냐를 나타내는 값을 속도라고 한다. 속력과는 약간 다른 개 념으로 이해해야 한다. 자동차가 일정한 속력으로 직선을 달릴 때 속도는 일정하다. 자동차가 구불구불한 도로를 달릴 때 속력 은 일정해도 방향이 바뀌기 때문에 속도는 일정하다고 얘기할 수 없는 것이다.

### DB의 격리수준에 대해 설명해보라

- dirty-read : A 트랜잭션에서 레코드의 데이터를 1에서 2로 변경하고 아직 커밋하지 않았을때 B 트랜잭션에서 동일 레코드를 조회하면 조회한 데이터는 2가 될 것입니다. 이때 A 트랜잭션이 롤백이 실행되고 B 트랜잭션에서 조회한 데이터 2를 3으로 변경한다면 정상적이지 않은 변경일 수 있을 것입니다.

- non-repeatable-read : A 트랜잭션에서 데이터를 조회할 때 데이터가 1이었고, B 트랜잭션에서 해당 레코드의 데이터를 1에서 2로 변경이 발생하였다면 A 트랜잭션에서 데이터를 다시 조회하였을 때 조회된 데이터는 2가 됩니다. 그런데 B 트랜잰션에서 롤백이 발생하고 A 트랜잭션에서 데이터를 2에서 3으로 변경한다면 정상적으로 변경된 것이 아닐 수 있습니다.

- phantom-read : A 트랜잭션에서 1의 조건으로 데이터를 검색하였고, B 트랜잭션에서 1조건의 가진 데이터를 새롭게 추가/삭제/변경하는 경우, A 트랜잭션에서 1의 조건으로 데이터를 다시 검색하였을 때 B 트랜잭션에서 변경한 데이터를 조회할 수 있게 됩니다. 이때 B 트랜잭션에서 롤백을 실행한 후 A 트랜잭션에서 조회한 데이터를 변경하게 되면 해당 데이터들은 정상적인 변경이 아닐 수 있습니다.

아래로 내려갈수록 격리수준이 높아져 위에 언급한 문제가 발생할 가능성은 줄어들지만 동시 처리 성능은 떨어집니다.

- shared-lock : select에 대한 lock을 직접 걸지 않고 innoDB가 각 행에 대한 lock을 실행한다.
- exclusive-lock : update, delete에 대한 lock을 실행한다.

1. Read-Uncommitted
   트랜젝션의 변경내용이 commit이나 rolback 여부에 관계없이 다른 트랜잭션에서 보여집니다. 동시처리 성능이 가장 높습니다.
   dirty-read, non-repeatable-read, phantom-read

2. Read-Committed
   어떤 트랜잭션에서 데이터의 변경이 일어나도 commit이 완료된 데이터만 조회 가능합니다.
   non-repeatable-read, phantom-read

3) Repeatable-Read
   트랜잭션 내 조회한 데이터의 내용이 항상 동일함을 보장해 줍니다.
   phantom-read

4) Serializable
   트랜잭션 내 조회한 데이터의 내용이 항상 동일하며 다른 트랜잭션에서의 변경 또한 불가능합니다.
   dead-lock

### 스프링 부트 배치의 장점

- 대용량 데이터 처리에 최적화 되어있고 고성능을 발휘한다.
- 효과적인 로깅과 통계, 트랜잭션 처리를 위한 필수 기능을 지원한다.
- 예외 처리에 대한 방어 기능이 있다.
- 반복적인 작업 프로세스를 줄여줘서 비지니스 로직에 집중할 수 잇다.

### 스프링 부트 배치 사용 시 주의사항

- 최대한 단순하게 구현해야 한다.
- I/O 사용을 최소화 해야한다.
- 다른 서버에 영향이 가지 않도록 주의해야 한다.
- 스케줄러를 제공하지 않는다. crontab 대신에 쿼츠와 같은 라이브러리 사용을 권장한다.

### 쿼츠의 클러스터링

고가용성과 확장성을 위해 쿼츠의 클러스터링을 사용할 수 있을 것입니다. 하지만 현재 회사에서는 해당 기능은 사용하지 않았습니다.

### junit4 vs junit5

- 변경되거나 새롭게 추가된 어노테이션 (@BeforeAll, @AfterAll, @Disabled, @Tag, @ExtendWith, @Nested)
- 아키텍쳐 변경 (JUnit Platform - 테스트 엔진 정의, JUnit Jupiter - 새로운 JUnit 기능 제공, JUnit Vintage - 하위버전 호환)
- JDK 버전 요구사항 변경 (JUnit4 - Java 5, JUnit5 - Java 8)
- 다양한 ParameterizedTest 제공

### JPA 순환 참조 해결 방법

1. @JsonIgnore: 가장 단순하게 해결할 수 있는 방법, 해당 프로퍼티를 null로 처리, 추천하지 않음
2. @JsonManagedReference, @JsonBackReference: 순환참조를 방어하기 위핸 어노테이션, 부모 클래스에 @JsonManagedReference, 자식 클래스에 @JsonBackReference
3. DTO 사용: Entity를 response body로 사용하는 것은 추천하지 않는다. 그래서 1, 2번을 사용한 해결법은 근본적인 해결책이 아닐 수 있다. 양방향 맵핑을 사용해야 하는 경우라면 DTO를 이용하는 방법이 최선이라 생각한다.
4. 매핑 재설정: 양방향 매핑이 반드시 필요한지 다시 고민한다. 양방향 매핑은 반드시 필요한 경우가 아니라면 사용하지 않는 것을 권장한다.

### 스프링 부트 구성

- Job
  배치 처리과정의 단위, 여러개의 Step을 가질 수 있음
- Step
  Job을 처리하는 실질적인 단위
- ItemReader
  Step의 대상이 되는 배치 데이터를 읽어오는 역할
- ItemProcessor
  ItemReader로 불러온 데이터를 처리하는 역할
- ItemWriter
  배치 데이터를 저장하는 역할

## 질문?

- 개발자들이 사용하는 장비와 도서 지원 등 사내 지원 범위가 어떤지 궁금합니다.
- 현재 제가 지원하는 팀에서의 제 역할과 팀의 개발문화
- 기술 부채를 어떻게 해결해 가고 있는지?
