---
layout: single
title: "당근마켓 1차 면접 준비"
categories:
  - INTERVIEW
tags:
  - 당근마켓
---

## 자기소개

안녕하세요. 이번에 당근마켓에 개발자로 입사지원한 남경호 입니다. 저는 지난 개발경력 동안 API 서버, Back-Office 서버, Batch 서버등 백앤드 서버개발에 대한 개발 경험을 가지고 있습니다.

처음 재직한 닉스테크라는 회사는 보안관련 솔루션을 판매하는 회사였습니다. 그곳에서 보안관제용 Back-Office 기능개발과 대시보드, 배치서비스, 보고서 및 Splunk, Archsight, Qradar와 같은 SIEM 장비 연동과 관련한 기능 개발을 담당하였습니다. 주로 데이터 연동과 저장된 데이터를 시각화 하는 부분을 집중적으로 개발하였습니다.

현재 재직중인 엑스트라이버라는 회사는 트립스토어라는 여행패키지 상품 가격 비교 플랫폼 서비스를 운영하고 있는 회사입니다. 주로 클라이언트를 위한 API 개발과 Back-office 및 배치 서비스 개발을 담당하였고, 현재는 예약파트에서 B2B 사이트를 위한 예약 관련 기능 개발을 담당하고 있습니다.
엑스트라이버에서는 API의 속도 및 다량의 데이터를 어떻게 다룰지, 어떻게 API를 설계하면 좋은지를 고민하며 개발을 진행하고 있습니다.

저는 당근마켓에서 제가 가진 이러한 역량을 잘 발휘하여 서비스를 발전시킬 수 있는 개발자가 될 수 있다고 자신합니다.

## 지원동기

당근마켓이 일하는 방식을 보고 정말 함께 일해보고 싶다라는 생각을 가지게 되었습니다. 저는 목록을 나열할때 가장 중요하게 생각하는 부분이 1번이라고 생각합니다. 당근마켓이 일하는 방식 중 1번은 "스스로 업무를 선택해요"라는 말이었습니다. 그만큼 업무에 대한 적극성을 중요시하고 자율성이 높다는 말로 이해를 하였습니다. 저는 일을 할때 자발성이 중요하다고 생각합니다.
현재 회사에서 2018년에 입사하여 최근 까지 저는 서비스 성장에 많은 기여를 하였고 언제나 적극적으로 더 좋은 기능을 만들기 위한 노력을 아끼지 않았습니다. 저는 당근마켓에서 제가 잘할 수 있는 일을 적극적으로 역량을 발휘하며 함께 성장해 나가고 싶다는 생각을 하게 되었고 그래서 지원하게 되었습니다.

## 이직사유

저의 백엔드 개발 기술에 대한 전문성을 더 발전 시키고 싶어서 이직을 결심하게 되었습니다. 특히 마이크로 서비스에 대한 경험을 쌓고 싶은데요 당근마켓에서는 현재 마이크로 서비스로 백엔드 서버를 운영하고 있는 것으로 알고 있습니다. 그리고 당근마켓이 지향하는 동료상이 제가 추구하고 함께 일하고 싶은 동료상과 아주 잘 맞아서 이직을 결심하게 되었습니다.

## 유연한 코드란?

유연한 코드란 누구나 그 코드를 읽어도 그 코드가 어떤 책임을 가지고 동작하는지 알 수 있고 변경에 대한 두려움이 없는 코드를 저는 유연한 코드라고 생각합니다.

## 일라스틱 서치에서 수정에 대한 처리는 어떻게 하나?

현재 트립스토에서는 AWS에서 제공하는 일라스틱 서치 서비스를 이용하여 일라스틱 서치를 사용하고 있습니다. 크롤링 서버나 API 서버에 의해서 상품데이터가 추가 또는 변경되면 일라스틱 서치에게도 갱신요청을 보내는 방식으로 사용하고 있습니다. 제가 알기로는 이러한 방법은 일라스틱 서치가 1000만건 이상의 수많은 데이터를 다룰 경우 성능 이슈가 발생할 수 있고 이를 해결하기 위해서 새로운 인덱스를 생성하고 교체해 주는 방식으로 검색엔진의의 성능을 최적화 하는 것으로 알고 있습니다. 하지만 저희가 다루는 상품의 개수는 해당 방식을 고려할 만큼 많지가 않고 실시간으로 인덱스를 유지할 필요성이 있어 현재까지는 실시간으로 인덱스를 갱신해주는 방식을 사용하고 있습니다.

## SVN과 GIT의 차이점

SVN과 GIT의 가장 큰 차이점은 GIT은 개발자가 자신만의 커밋 히스토리를 가질 수 있고 SVN은 그럴 수 없다는 것입니다. 이것은 commit한 작업을 개발자가 원하는 순간에 할 수 있는가, 원하는 순간에 머지할 수 있는가의 차이이기 때문에 개발자가 유연하게 소스를 관리할 수 있다는 점이 큰 차이라고 생각합니다.

## ORM의 장단점

장점

- 개발자가 SQL에 대한 전문적인 지식이 부족해도 최적화된 쿼리를 제공해준다.
- 객체지향적인 코드로 테이블 구조에 맞춘 코드를 작성하지 않으므로 직관적인 코드를 작성할 수 있다.
- 유지보수성이 좋다.

단점

- 복잡도에 따라 구현 난이도가 많이 증가한다.
- 잘못된 구현은 성능에 많은 영향을 끼칠 수 있다.
- 통계쿼리의 경우 ORM으로 구현하기 어려울 수 있다.

## 예약시 가격 변경에 대한 대처법

예약요청 정보에서 가격을 전송하여 현재의 가격과 전송된 가격을 비교하여 동일한 경우 예약프로세스를 진행하고 동일하지 않은 경우 예약 실패응답을 반환한다.

## 동시성 문제 해결방법

상품 데이터의 경우 크롤러, API, 관리자 등 많은 곳에서 수정요청이 발생하고 동시에 발생할 가능성이 존재하였습니다.
저희는 이러한 동시성을 해결하기 위해 아래와 같은 방식을 선택하였습니다.

하나는 수정요청에 대한 이력을 기록하고 실패한 요청에 대해서는 재시도를 하도록 하는 기능으로 해당 문제를 해결하고자 하였습니다. 해당 방법은 최종일관성은 보장하지만 필요한 시점에 데이터가 꼭 변경되어야 하는 경우에는 사용할 수 없었습니다.

또다른 하나는 특가시스템에서 적용한 방식인데요, 처음 특가시스템을 구현하였을 때에는 특가정보를 업데이트 하는 방식으로 구현하였었는데요, DB 업데이트인 경우 동시성 문제가 발생할 가능성이 있었고 이를 해결하기위해 특가정보를 무조건 등록만 하도록 하고 데이터를 조회 시 조건에 맞는 가격이 노출되도록 기능을 변경하여 해결하였습니다.

### 요즘 관심 있는 분야는 무엇인가?

최근 비동기, Non-Blocking 프로그래밍과 CQRS에 대해 많은 관심을 쏟고 있습니다. CQRS는 어플리케이션의 복잡성을 해결하고자 하는 노력에서 좀더 깊이 공부하고 실무에 적용하면 좋을 것 같아 공부하고 있는데요, 해당 기능을 구현할 때 비동기 프로세스로 기능을 구현할 필요가 있어서 비동기, Non-Blocking으로 서버를 구현하는 방법에 대해서도 공부하고 있습니다.

### Thread와 Process의 차이점에 대해 설명해 보라.

- Process

  컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

- Thead

  Process 내에서 실행되는 여러 흐름의 단위

  Process는 1개 이상의 Thread를 가질 수 있습니다. 멀티프로세스 보다 멀티쓰레드로 작업을 실행하는 경우 자원을 할당하는 시스템 콜이 줄어들어 자원을 좀더 효율적으로 사용할 수 있습니다. 뿐만 아니라 프로세스간의 통신보다 쓰레드간의 통신이 비용이 적게들어 통신부담도 줄어듭니다. 하지만 멀티쓰레드의 경우 전역변수의 사용으로 인한 동기화 문제를 항상 고려해야 합니다.

### 사용해 본 디자인 패턴에 대해서 설명해 보라.

- Dependency Injection
  구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나입니다.
  의존성 주입과 항상 함께 나오는 단어가 inversion of control입니다. 의존 주입 시 구현체가 아닌 인터페이스를 주입한다면 종속성을 감소시키고 재사용성을 높일 수 있습니다. 테스트 코드를 작성하기에도 좋습니다.

- Decorator
  주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴입니다.

- Abstract Factory
  구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스

- Factory Method
  객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴

- Command
  실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴

- Observer
  한 객체의 상태 변화에 따라 다른 객체의 상태도 연동이 되도록 일대다 객체 의존관게를 구성하는 패턴

- Template Method
  어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해서 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴

- Composite
  여러개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별없이 다루게 해주는 패턴

- Stratege
  행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있는 패턴

### String, StringBuilder, StringBuffer 차이점

1. String
   불변 개체이다. 그래서 새롭게 문자열이 생성될 때마다 메모리 공간이 변경되는 것이 아니라 새롭게 생성되므로 문자열 연산시 성능이 좋지 않다.
   문자열 연산이 적고 멀티쓰레드 환경에 사용하기 적합

2. StringBuffer
   동기화를 지원하기 때문에 Thread-safe하다.

3. StringBuilder
   동기화를 지원하지 않기 때문에 멀티쓰레드 환경에 사용하기에 적합하지 못하다. 연산처리가 StringBuffer보다 빠르다.

### 코틀린을 사용하면서 느꼈던 장점과 단점

- 장점

  - 코드가 간결해진다 -> 가독성이 좋아진다.
  - null safe하기 때문에 null pointer exception을 만날 확율을 많이 줄일 수 있다.
  - 자바와의 호환성이 좋기 때문에 자바에 익숙한 사람들이 코틀린을 사용하는데 러닝커브가 낮다.
  - extention function 지원
  - data 클래스
  - immutablity
  - 타입추론이 가능한 경우 타입을 생략해도 된다.

- 단점

  - 순수 자바보다 패키지 사이즈가 커지는 경향이 있다.
  - 빌드 시간이 조금 느리다.
  - 스프링 프레임워크에 한정되긴 하지만 레퍼런스가 많지 않습니다.

### 스프링의 버전별 차이점

- Spring 3

  - JAVA 5+ 지원
  - 전체 프레임워크를 여러개로 분리
  - SPEL 제공
  - REST API 지원 추가

- Spring 4

  - JAVA 8
  - Starter Pack 지원
  - Hibernate 3.6, Joda-Time 2.0 등 지원
  - 람다식, Optional 등 Framework 레벨에서 지원
  - REST방식 Controller 지원

- Spring 5
  - JAVA8을 표준으로 사용하며 8+ 버전 지원
  - Reactive Programing Model (WebFlux)
  - 함수형 프로그래밍 with Kotlin
  - Testing improvement (junit5 완벽지원, 병렬테스트 지원, Spring Webflux 테스트 지원)

### TDD에 대해 설명하라

테스트 주도 개발(Test-driven development TDD)은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나이다. 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다. 그런 후에, 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다. 마지막으로 작성한 코드를 표준에 맞도록 리팩토링한다.

### 스크럼과 칸반의 차이점에 대해 설명하라

- 스크럼
  스프린트를 기반으로 애자일 방법론을 실행하는 것을 말합니다. 스프린트 작업 단위를 부여하고 작업을 계획 실행 후 회고하는 방식으로 진행됩니다. 회고한 내용을 다음 스프린트에 반영하여 계속 진행하는 방식입니다. 짧은 개발 주기와 피드백을 추구합니다.
  주목할만한 특징중 하나는 Hot Fix는 현재 진행중인 스프린트에 절대 넣지 않는 것입니다.

- 칸반
  Work In Process를 제한하여 애자일 방법론을 실행합니다. 칸반의 특징은 스크럼과 달리 스프린트 기간이 정해지지 않는다는 것입니다. 이슈가 생기면 백로그에 쌓이게 되고 작업자는 작업할 여유가 되면 해당 카드를 자신에게 할당하여 in progress로 상태를 바꾸고 처리하는 방식으로 언제 그 일이 처리가 될지는 정해지지 않습니다. 중요한건 in progress의 상태를 가진 카드를 제한하는 것입니다. 백로그와 다르게 Hot Fix는 언제든지 백로그에 추가될 수 있고 우선순위에 따라 언제든지 프로젝트를 위한 카드보다 먼저 처리될 수 있습니다.

### 리펙토링이란 무엇인가

'결과의 변경 없이 코드의 구조를 재조정함'을 뜻한다. 주로 가독성을 높이고 유지보수를 편하게 한다. 버그를 없애거나 새로운 기능을 추가하는 행위는 아니다. 사용자가 보는 외부 화면은 그대로 두면서 내부 논리나 구조를 바꾸고 개선하는 유지보수 행위이다.

저는 그래서 테스트 코드가 없는 리펙토링은 반쪽짜리 리펙토링이라고 생각합니다. 왜냐하면 결과의 변경이 없었다는 것을 보장해주는 테스트가 없으면 구조를 재조정한 후에 그 결과가 같다는 것을 보장할 수 없기 때문입니다.

### 속력과 속도의 차이가 무엇인가?

- 속력
  속력 은 여러분이 여행하는 데 들어간 시간과 여행한 거리의 관계, 즉 시간당 거리이다. 다른 말로 한다면 1초 동안에 몇 m를 이동 했는가를 나타낼 수 있는 것이다. 속력은 시간과 거리로 나타내 는 스칼라량이다. 여기에는 방향이 포함되지 않는다.

- 속도
  속도 는 거리,시간, 방향을 모두 나타내는 벡터량이다. 속도를 다르 게 설명한다면 속도는 1초동안에 처음 위치에서 얼마의 변화가 있느냐를 나타내는 값을 속도라고 한다. 속력과는 약간 다른 개 념으로 이해해야 한다. 자동차가 일정한 속력으로 직선을 달릴 때 속도는 일정하다. 자동차가 구불구불한 도로를 달릴 때 속력 은 일정해도 방향이 바뀌기 때문에 속도는 일정하다고 얘기할 수 없는 것이다.

### DB의 격리수준에 대해 설명해보라

- dirty-read : A 트랜잭션에서 레코드의 데이터를 1에서 2로 변경하고 아직 커밋하지 않았을때 B 트랜잭션에서 동일 레코드를 조회하면 조회한 데이터는 2가 될 것입니다. 이때 A 트랜잭션이 롤백이 실행되고 B 트랜잭션에서 조회한 데이터 2를 3으로 변경한다면 정상적이지 않은 변경일 수 있을 것입니다.

- non-repeatable-read : A 트랜잭션에서 데이터를 조회할 때 데이터가 1이었고, B 트랜잭션에서 해당 레코드의 데이터를 1에서 2로 변경이 발생하였다면 A 트랜잭션에서 데이터를 다시 조회하였을 때 조회된 데이터는 2가 됩니다. 그런데 B 트랜잰션에서 롤백이 발생하고 A 트랜잭션에서 데이터를 2에서 3으로 변경한다면 정상적으로 변경된 것이 아닐 수 있습니다.

- phantom-read : A 트랜잭션에서 1의 조건으로 데이터를 검색하였고, B 트랜잭션에서 1조건의 가진 데이터를 새롭게 추가/삭제/변경하는 경우, A 트랜잭션에서 1의 조건으로 데이터를 다시 검색하였을 때 B 트랜잭션에서 변경한 데이터를 조회할 수 있게 됩니다. 이때 B 트랜잭션에서 롤백을 실행한 후 A 트랜잭션에서 조회한 데이터를 변경하게 되면 해당 데이터들은 정상적인 변경이 아닐 수 있습니다.

아래로 내려갈수록 격리수준이 높아져 위에 언급한 문제가 발생할 가능성은 줄어들지만 동시 처리 성능은 떨어집니다.

- shared-lock : select에 대한 lock을 직접 걸지 않고 innoDB가 각 행에 대한 lock을 실행한다.
- exclusive-lock : update, delete에 대한 lock을 실행한다.

1. Read-Uncommitted
   트랜젝션의 변경내용이 commit이나 rolback 여부에 관계없이 다른 트랜잭션에서 보여집니다. 동시처리 성능이 가장 높습니다.
   dirty-read, non-repeatable-read, phantom-read

2. Read-Committed
   어떤 트랜잭션에서 데이터의 변경이 일어나도 commit이 완료된 데이터만 조회 가능합니다.
   non-repeatable-read, phantom-read

3. Repeatable-Read
   트랜잭션 내 조회한 데이터의 내용이 항상 동일함을 보장해 줍니다.
   phantom-read

4. Serializable
   트랜잭션 내 조회한 데이터의 내용이 항상 동일하며 다른 트랜잭션에서의 변경 또한 불가능합니다.
   dead-lock

### 스프링 부트 배치의 장점

- 대용량 데이터 처리에 최적화 되어있고 고성능을 발휘한다.
- 효과적인 로깅과 통계, 트랜잭션 처리를 위한 필수 기능을 지원한다.
- 예외 처리에 대한 방어 기능이 있다.
- 반복적인 작업 프로세스를 줄여줘서 비지니스 로직에 집중할 수 잇다.

### 스프링 부트 배치 사용 시 주의사항

- 최대한 단순하게 구현해야 한다.
- I/O 사용을 최소화 해야한다.
- 다른 서버에 영향이 가지 않도록 주의해야 한다.
- 스케줄러를 제공하지 않는다. crontab 대신에 쿼츠와 같은 라이브러리 사용을 권장한다.

### 쿼츠의 클러스터링

고가용성과 확장성을 위해 쿼츠의 클러스터링을 사용할 수 있을 것입니다. 하지만 현재 회사에서는 해당 기능은 사용하지 않았습니다.

### junit4 vs junit5

- 변경되거나 새롭게 추가된 어노테이션 (@BeforeAll, @AfterAll, @Disabled, @Tag, @ExtendWith, @Nested)
- 아키텍쳐 변경 (JUnit Platform - 테스트 엔진 정의, JUnit Jupiter - 새로운 JUnit 기능 제공, JUnit Vintage - 하위버전 호환)
- JDK 버전 요구사항 변경 (JUnit4 - Java 5, JUnit5 - Java 8)
- 다양한 ParameterizedTest 제공

### JPA 순환 참조 해결 방법

1. @JsonIgnore: 가장 단순하게 해결할 수 있는 방법, 해당 프로퍼티를 null로 처리, 추천하지 않음
2. @JsonManagedReference, @JsonBackReference: 순환참조를 방어하기 위핸 어노테이션, 부모 클래스에 @JsonManagedReference, 자식 클래스에 @JsonBackReference
3. DTO 사용: Entity를 response body로 사용하는 것은 추천하지 않는다. 그래서 1, 2번을 사용한 해결법은 근본적인 해결책이 아닐 수 있다. 양방향 맵핑을 사용해야 하는 경우라면 DTO를 이용하는 방법이 최선이라 생각한다.
4. 매핑 재설정: 양방향 매핑이 반드시 필요한지 다시 고민한다. 양방향 매핑은 반드시 필요한 경우가 아니라면 사용하지 않는 것을 권장한다.

### 스프링 부트 배치 구성

- Job
  배치 처리과정의 단위, 여러개의 Step을 가질 수 있음
- Step
  Job을 처리하는 실질적인 단위
- ItemReader
  Step의 대상이 되는 배치 데이터를 읽어오는 역할
- ItemProcessor
  ItemReader로 불러온 데이터를 처리하는 역할
- ItemWriter
  배치 데이터를 저장하는 역할

### Cache의 대상이 되는 정보

- 단순하거나 단순한 구조를 가진 정보
- 반복적으로 동일한 정보를 제공해야 하는 경우
- 정보의 변경주기가 빈번하지 않으면서 단위 처리 시간이 오래 소요되는 경우
- 정보의 실시간성이 필요하지 않은 경우

## Swap Memory

주 메모리가 부족할 때 하드디스크와 같은 공간을 메모리로 사용하기 위한 가상 메모리이다.

## Synchronous, Asynchronous, Blocking, Non-Blocking

- Synchronous vs Asynchronous
  현재 작업의 응답이 다음 작업 요청의 타이밍이 맞아야 하는지 맞지 않아도 되는 지에 따른 구분을 말한다. 함수의 완료여부를 누가 신경 쓰느냐가 관심사이다.

- Blocking vs Non-Blocking
  직접 제어할 수 없는 대상의 작업이 끝날 때까지 그 제어권을 넘겨받지 않고 기다리느냐 기다리지 않느냐에 따른 구분을 말한다. 호출되는 함수가 바로 리턴되냐 아니냐가 관심사이다.

## Spring Bean Scope

- Singleton
  Spring IoC Container 별로 단일 객체를 생성하고 유지한다.

- Prototype
  빈의 요청이 있을 때마다 새로운 인스턴스를 생성한다.

- Request
  HTTP request에 대해 새로운 인스턴스를 생성하고 유지한다.

- Session
  HTTP session의 수명기간 동안 새로운 인스턴스를 생성하고 유지한다.

- Application
  Web Application에 대해 한번 새로운 인스턴스를 생성하고 유지한다.

## Filter, Interceptor, AOP

Servlet Request <> filter <> DispatcherServlet <> Interceptor <> AOP <> Controller

- Filter
  Web Application에 등록을 하고 DispatcherServlet 이전에 실행된다. 주로 인코딩 처리, XSS 방어등을 위해 사용한다.
  예외 처리는 Web Server에게 위임해야한다. Tomcat의 경우 Error page 구현 등을 예로 들 수 있다. 대표적인 함수 `doFilter`

- Interceptor
  Spring의 Context에 등록을 하고 DispatcherServlet과 Controller 사이에 실행된다. 주로 로그인 체크, 권한체크, 프로그램 실행시간 계산 등을 위해 사용한다. 예외처리는 @ControllerAdvice, @ExceptionHandler등을 이용하여 처리할 수 있다. 대표적인 함수 `preHandle`, `postHandle`, `afterCompletion`, `afterConcurrentHandlingStarted`

- AOP
  Interceptor와 Controller 사이에 실행된다. 주로 로깅, 트렌젝션, 에러 처리 등을 위해 사용한다. AOP와 Interceptor의 큰 차이는 파라미터 차이인데 AOP는 JoinPoint나 ProceedingJoinPoint를 사용하는 반면 Interceptor는 HttpServletRequest, HttpServletResponse를 사용한다. 대표적인 함수 `Before Advice`, `Around Advice`, `After Advice`

## Memory 영역

- Code 영역
  실행할 프로그램의 코드가 저장되는 영역. CPU는 코드영역에 저장된 명령어를 하나씩 가져가서 처리

- Data 영역
  프로그램의 전역 변수와 정적 변수가 저장되는 영역. 프로그램의 시작과 함께 할당되며 종료되면 소멸된다.

- Stack 영역
  함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역. 함수가 호출되면 할당되며 호출이 완료되면 소멸된다. 후입선출 방식에 따라 동작.

- Heap 영역
  사용자가 직접 관리할 수 있는 메모리 영역. 사용자에 의해 메모리 공간이 동적으로 할당 되고 해제된다. Java의 가비지 컬렉션이 동작하는 영역

## 가비지 컬렉터 종류

- Serial GC
  하나의 CPU로 Young영역과 Old영역을 연속적으로 Deletion and Compacting 수행한다. Mark-Sweep-Compact라는 알고리즘을 사용. 컬렉션이 수행될 때 애플리케이션이 정지된다.

- Parallel GC
  자바 9이전에 기본으로 사용하는 GC. 여러 CPU를 효과적으로 활용하기 위해 GC수행시 멀티스레드를 사용. Default로 young generation에서만 멀티스레드를 활용하나, 옵션을 통해 old generation에서도 멀티스레딩 활용가능. Deletion and Compacting 수행

- CMS Collector
  가비지 컬렉션 작업을 애플리케이션 스레드와 동시 수행. stop-the-world시간 최소화. Compacting수행하지 않아서 memory를 더 많이 차지. Compacting 단계에 stop-the-world 시간이 많이 발생할 수 있어 Compacting 주기에 따라 성능 차이가 발생

- G1 GC
  G1 컬켁터는 바둑판 모양으로 구성되어있으며 약 2000개의 구역을 사용. 이 바둑판 모양의 구역에서 일부를 선정하여 Young 영역으로 지정한 후 해당 구역에 데이터가 꽉 차면 GC를 진행. GC 후 살아있는 객체만 Servivor영역으로 이동.
  Java7부터 사용가능. Java9에서는 default GC로 설정

## 마지막 할말?

저는 기능을 개발할 때 되도록 많은 사람들과 논의를 통해서 요구사항을 정의하고 기능 구현에 대한 설계를 해왔습니다. 그리고 제가 담당한 기능에 대해서는 최대한 깊이 이해하려고 노력하고 사용자가 편리하게 사용할 수 있도록 기능을 구현하는데 집중을 하여왔습니다. 이러한 저의 노력은 현재 재직 중인 회사에서 사용중인 서비스에 대한 높은 이해력을 가질 수 있도록 하였습니다. 또한 저는 끊임없이 자기 개발을 위한 노력을 이어가고 있습니다. 저의 블로그를 보시면 아실 수 있으시겠지만 저는 제가 가진 개발 기술을 향상 시키고 부족한 부분을 채우기 위한 노력을 항상 하고 있으며 이러한 노력을 잊지 않기 위해서 회고나 블로그 작성을 통해서 기록을 하고 있습니다.

저의 이런 노력과 역량은 제가 지원한 당근마켓에서 요구하는 백엔드 개발자 역량에 아주 잘 맞는다고 생각하고 당근마켓의 구성원으로 맡은 바 업무를 잘 진행할 수 있을 것이라 생각합니다. 부디 당근마켓의 일원이 되어 함께 긍정적으로 크게 발전 할 기회를 주셨으면 합니다. 감사합니다.

## 당근마켓이 지향하는 동료

- 일하는게 재미있는 사람
- 주도적이고 사용자 가치를 최우선으로 생각하는 사람
- 인성, 인품이 훌륭한 사람
- 새로운 도전을 좋아하고, 회사의 성장과 함께 성장할 수 있는 사람
- 다른 사람의 성장에 도움이 되면서 자신도 성장하는 사람
- 일과 삶의 균형이 있는 사람

## 당근마켓이 일하는 방식

- 스스로 업무를 선택해요
- 모든 정보는 공유해요
- 직급이 없어요
- 즐겁게 일하고 크게 성장해요
- 나보다 뛰어난 동료가 있어요
- 사람의 수만큼 다른 생각이 있다고 믿어요
- 우린 팀으로 일해요
- 먼저 실행해 봐요
- 소수정예 드림팀을 지향해요
- 사용자가 가장 중요해요

## 질문?

- 현재 제가 지원하는 개발팀의 구성원과 맡게 되는 역할에 대해 궁금합니다.

## 현재 트립스토어 서비스 구성도

![tripstore-diagram](/assets/images/draft/tripstore-diagram.png)
